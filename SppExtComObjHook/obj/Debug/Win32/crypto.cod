; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28105.4 

	TITLE	C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?HmacKeyblob@@3UHMAC_KEYBLOB@@A			; HmacKeyblob
msvcjmc	SEGMENT
__7242C389_ctype@h DB 01H
__90A1F774_basetsd@h DB 01H
__367CC694_corecrt_memcpy_s@h DB 01H
__35D7DDB3_corecrt_memory@h DB 01H
__DC9673E3_corecrt_wstring@h DB 01H
__A29A7DFB_string@h DB 01H
__3C23D660_guiddef@h DB 01H
__AF541008_winnt@h DB 01H
__76CD430D_winerror@h DB 01H
__737D49DB_winbase@h DB 01H
__1B9502AC_winuser@h DB 01H
__376EBCA0_winioctl@h DB 01H
__24E9E95F_stdlib@h DB 01H
__2CCBBE23_propidl@h DB 01H
__AD360DAF_oleauto@h DB 01H
__0396F1A5_stralign@h DB 01H
__EDBB2947_crypto@cpp DB 01H
msvcjmc	ENDS
_DATA	SEGMENT
?HmacKeyblob@@3UHMAC_KEYBLOB@@A DB 08H			; HmacKeyblob
	DB	02H
	DW	00H
	DD	06602H
	DD	010H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
CONST	SEGMENT
?AesKeyV5Blob@@3UAES_128_KEYBLOB@@B DB 08H		; AesKeyV5Blob
	DB	02H
	DW	00H
	DD	0660eH
	DD	010H
	DB	0cdH
	DB	07eH
	DB	079H
	DB	06fH
	DB	02aH
	DB	0b2H
	DB	05dH
	DB	0cbH
	DB	055H
	DB	0ffH
	DB	0c8H
	DB	0efH
	DB	083H
	DB	064H
	DB	0c4H
	DB	070H
	ORG $+4
?SBox@@3QBEB DB	063H					; SBox
	DB	07cH
	DB	077H
	DB	07bH
	DB	0f2H
	DB	06bH
	DB	06fH
	DB	0c5H
	DB	030H
	DB	01H
	DB	067H
	DB	02bH
	DB	0feH
	DB	0d7H
	DB	0abH
	DB	076H
	DB	0caH
	DB	082H
	DB	0c9H
	DB	07dH
	DB	0faH
	DB	059H
	DB	047H
	DB	0f0H
	DB	0adH
	DB	0d4H
	DB	0a2H
	DB	0afH
	DB	09cH
	DB	0a4H
	DB	072H
	DB	0c0H
	DB	0b7H
	DB	0fdH
	DB	093H
	DB	026H
	DB	036H
	DB	03fH
	DB	0f7H
	DB	0ccH
	DB	034H
	DB	0a5H
	DB	0e5H
	DB	0f1H
	DB	071H
	DB	0d8H
	DB	031H
	DB	015H
	DB	04H
	DB	0c7H
	DB	023H
	DB	0c3H
	DB	018H
	DB	096H
	DB	05H
	DB	09aH
	DB	07H
	DB	012H
	DB	080H
	DB	0e2H
	DB	0ebH
	DB	027H
	DB	0b2H
	DB	075H
	DB	09H
	DB	083H
	DB	02cH
	DB	01aH
	DB	01bH
	DB	06eH
	DB	05aH
	DB	0a0H
	DB	052H
	DB	03bH
	DB	0d6H
	DB	0b3H
	DB	029H
	DB	0e3H
	DB	02fH
	DB	084H
	DB	053H
	DB	0d1H
	DB	00H
	DB	0edH
	DB	020H
	DB	0fcH
	DB	0b1H
	DB	05bH
	DB	06aH
	DB	0cbH
	DB	0beH
	DB	039H
	DB	04aH
	DB	04cH
	DB	058H
	DB	0cfH
	DB	0d0H
	DB	0efH
	DB	0aaH
	DB	0fbH
	DB	043H
	DB	04dH
	DB	033H
	DB	085H
	DB	045H
	DB	0f9H
	DB	02H
	DB	07fH
	DB	050H
	DB	03cH
	DB	09fH
	DB	0a8H
	DB	051H
	DB	0a3H
	DB	040H
	DB	08fH
	DB	092H
	DB	09dH
	DB	038H
	DB	0f5H
	DB	0bcH
	DB	0b6H
	DB	0daH
	DB	021H
	DB	010H
	DB	0ffH
	DB	0f3H
	DB	0d2H
	DB	0cdH
	DB	0cH
	DB	013H
	DB	0ecH
	DB	05fH
	DB	097H
	DB	044H
	DB	017H
	DB	0c4H
	DB	0a7H
	DB	07eH
	DB	03dH
	DB	064H
	DB	05dH
	DB	019H
	DB	073H
	DB	060H
	DB	081H
	DB	04fH
	DB	0dcH
	DB	022H
	DB	02aH
	DB	090H
	DB	088H
	DB	046H
	DB	0eeH
	DB	0b8H
	DB	014H
	DB	0deH
	DB	05eH
	DB	0bH
	DB	0dbH
	DB	0e0H
	DB	032H
	DB	03aH
	DB	0aH
	DB	049H
	DB	06H
	DB	024H
	DB	05cH
	DB	0c2H
	DB	0d3H
	DB	0acH
	DB	062H
	DB	091H
	DB	095H
	DB	0e4H
	DB	079H
	DB	0e7H
	DB	0c8H
	DB	037H
	DB	06dH
	DB	08dH
	DB	0d5H
	DB	04eH
	DB	0a9H
	DB	06cH
	DB	056H
	DB	0f4H
	DB	0eaH
	DB	065H
	DB	07aH
	DB	0aeH
	DB	08H
	DB	0baH
	DB	078H
	DB	025H
	DB	02eH
	DB	01cH
	DB	0a6H
	DB	0b4H
	DB	0c6H
	DB	0e8H
	DB	0ddH
	DB	074H
	DB	01fH
	DB	04bH
	DB	0bdH
	DB	08bH
	DB	08aH
	DB	070H
	DB	03eH
	DB	0b5H
	DB	066H
	DB	048H
	DB	03H
	DB	0f6H
	DB	0eH
	DB	061H
	DB	035H
	DB	057H
	DB	0b9H
	DB	086H
	DB	0c1H
	DB	01dH
	DB	09eH
	DB	0e1H
	DB	0f8H
	DB	098H
	DB	011H
	DB	069H
	DB	0d9H
	DB	08eH
	DB	094H
	DB	09bH
	DB	01eH
	DB	087H
	DB	0e9H
	DB	0ceH
	DB	055H
	DB	028H
	DB	0dfH
	DB	08cH
	DB	0a1H
	DB	089H
	DB	0dH
	DB	0bfH
	DB	0e6H
	DB	042H
	DB	068H
	DB	041H
	DB	099H
	DB	02dH
	DB	0fH
	DB	0b0H
	DB	054H
	DB	0bbH
	DB	016H
?InvSBox@@3QBEB DB 052H					; InvSBox
	DB	09H
	DB	06aH
	DB	0d5H
	DB	030H
	DB	036H
	DB	0a5H
	DB	038H
	DB	0bfH
	DB	040H
	DB	0a3H
	DB	09eH
	DB	081H
	DB	0f3H
	DB	0d7H
	DB	0fbH
	DB	07cH
	DB	0e3H
	DB	039H
	DB	082H
	DB	09bH
	DB	02fH
	DB	0ffH
	DB	087H
	DB	034H
	DB	08eH
	DB	043H
	DB	044H
	DB	0c4H
	DB	0deH
	DB	0e9H
	DB	0cbH
	DB	054H
	DB	07bH
	DB	094H
	DB	032H
	DB	0a6H
	DB	0c2H
	DB	023H
	DB	03dH
	DB	0eeH
	DB	04cH
	DB	095H
	DB	0bH
	DB	042H
	DB	0faH
	DB	0c3H
	DB	04eH
	DB	08H
	DB	02eH
	DB	0a1H
	DB	066H
	DB	028H
	DB	0d9H
	DB	024H
	DB	0b2H
	DB	076H
	DB	05bH
	DB	0a2H
	DB	049H
	DB	06dH
	DB	08bH
	DB	0d1H
	DB	025H
	DB	072H
	DB	0f8H
	DB	0f6H
	DB	064H
	DB	086H
	DB	068H
	DB	098H
	DB	016H
	DB	0d4H
	DB	0a4H
	DB	05cH
	DB	0ccH
	DB	05dH
	DB	065H
	DB	0b6H
	DB	092H
	DB	06cH
	DB	070H
	DB	048H
	DB	050H
	DB	0fdH
	DB	0edH
	DB	0b9H
	DB	0daH
	DB	05eH
	DB	015H
	DB	046H
	DB	057H
	DB	0a7H
	DB	08dH
	DB	09dH
	DB	084H
	DB	090H
	DB	0d8H
	DB	0abH
	DB	00H
	DB	08cH
	DB	0bcH
	DB	0d3H
	DB	0aH
	DB	0f7H
	DB	0e4H
	DB	058H
	DB	05H
	DB	0b8H
	DB	0b3H
	DB	045H
	DB	06H
	DB	0d0H
	DB	02cH
	DB	01eH
	DB	08fH
	DB	0caH
	DB	03fH
	DB	0fH
	DB	02H
	DB	0c1H
	DB	0afH
	DB	0bdH
	DB	03H
	DB	01H
	DB	013H
	DB	08aH
	DB	06bH
	DB	03aH
	DB	091H
	DB	011H
	DB	041H
	DB	04fH
	DB	067H
	DB	0dcH
	DB	0eaH
	DB	097H
	DB	0f2H
	DB	0cfH
	DB	0ceH
	DB	0f0H
	DB	0b4H
	DB	0e6H
	DB	073H
	DB	096H
	DB	0acH
	DB	074H
	DB	022H
	DB	0e7H
	DB	0adH
	DB	035H
	DB	085H
	DB	0e2H
	DB	0f9H
	DB	037H
	DB	0e8H
	DB	01cH
	DB	075H
	DB	0dfH
	DB	06eH
	DB	047H
	DB	0f1H
	DB	01aH
	DB	071H
	DB	01dH
	DB	029H
	DB	0c5H
	DB	089H
	DB	06fH
	DB	0b7H
	DB	062H
	DB	0eH
	DB	0aaH
	DB	018H
	DB	0beH
	DB	01bH
	DB	0fcH
	DB	056H
	DB	03eH
	DB	04bH
	DB	0c6H
	DB	0d2H
	DB	079H
	DB	020H
	DB	09aH
	DB	0dbH
	DB	0c0H
	DB	0feH
	DB	078H
	DB	0cdH
	DB	05aH
	DB	0f4H
	DB	01fH
	DB	0ddH
	DB	0a8H
	DB	033H
	DB	088H
	DB	07H
	DB	0c7H
	DB	031H
	DB	0b1H
	DB	012H
	DB	010H
	DB	059H
	DB	027H
	DB	080H
	DB	0ecH
	DB	05fH
	DB	060H
	DB	051H
	DB	07fH
	DB	0a9H
	DB	019H
	DB	0b5H
	DB	04aH
	DB	0dH
	DB	02dH
	DB	0e5H
	DB	07aH
	DB	09fH
	DB	093H
	DB	0c9H
	DB	09cH
	DB	0efH
	DB	0a0H
	DB	0e0H
	DB	03bH
	DB	04dH
	DB	0aeH
	DB	02aH
	DB	0f5H
	DB	0b0H
	DB	0c8H
	DB	0ebH
	DB	0bbH
	DB	03cH
	DB	083H
	DB	053H
	DB	099H
	DB	061H
	DB	017H
	DB	02bH
	DB	04H
	DB	07eH
	DB	0baH
	DB	077H
	DB	0d6H
	DB	026H
	DB	0e1H
	DB	069H
	DB	014H
	DB	063H
	DB	055H
	DB	021H
	DB	0cH
	DB	07dH
?AesKeyV6@@3QBEB DB 0a9H				; AesKeyV6
	DB	04aH
	DB	041H
	DB	095H
	DB	0e2H
	DB	01H
	DB	043H
	DB	02dH
	DB	09bH
	DB	0cbH
	DB	046H
	DB	04H
	DB	05H
	DB	0d8H
	DB	04aH
	DB	021H
	DB	0c9H
	DB	09cH
	DB	0bcH
	DB	0feH
	DB	02bH
	DB	09dH
	DB	0ffH
	DB	0d3H
	DB	0b0H
	DB	056H
	DB	0b9H
	DB	0d7H
	DB	0b5H
	DB	08eH
	DB	0f3H
	DB	0f6H
	DB	0d2H
	DB	091H
	DB	0feH
	DB	02bH
	DB	0f9H
	DB	0cH
	DB	01H
	DB	0f8H
	DB	049H
	DB	05aH
	DB	0b8H
	DB	02fH
	DB	0fcH
	DB	0d4H
	DB	04bH
	DB	0d9H
	DB	09eH
	DB	022H
	DB	0cbH
	DB	09bH
	DB	067H
	DB	02eH
	DB	0caH
	DB	063H
	DB	02eH
	DB	074H
	DB	072H
	DB	04cH
	DB	0d2H
	DB	0a0H
	DB	039H
	DB	095H
	DB	05H
	DB	030H
	DB	0e1H
	DB	02eH
	DB	011H
	DB	01eH
	DB	02bH
	DB	04dH
	DB	03fH
	DB	06aH
	DB	059H
	DB	01H
	DB	0edH
	DB	0caH
	DB	060H
	DB	094H
	DB	012H
	DB	0e0H
	DB	0c3H
	DB	07bH
	DB	03H
	DB	0feH
	DB	0e8H
	DB	036H
	DB	03cH
	DB	094H
	DB	0b1H
	DB	037H
	DB	0d1H
	DB	05eH
	DB	0d1H
	DB	0a3H
	DB	063H
	DB	0deH
	DB	0c9H
	DB	045H
	DB	069H
	DB	020H
	DB	021H
	DB	073H
	DB	055H
	DB	0b4H
	DB	090H
	DB	044H
	DB	084H
	DB	0eaH
	DB	041H
	DB	0e7H
	DB	0adH
	DB	05dH
	DB	05dH
	DB	01aH
	DB	0c4H
	DB	07dH
	DB	07cH
	DB	069H
	DB	091H
	DB	0c9H
	DB	0ecH
	DB	02dH
	DB	015H
	DB	023H
	DB	0adH
	DB	0caH
	DB	0efH
	DB	0c8H
	DB	029H
	DB	043H
	DB	0cfH
	DB	0b5H
	DB	055H
	DB	02aH
	DB	05eH
	DB	07cH
	DB	0b9H
	DB	07H
	DB	04bH
	DB	05fH
	DB	014H
	DB	0cdH
	DB	0dfH
	DB	032H
	DB	094H
	DB	0f0H
	DB	010H
	DB	087H
	DB	0c1H
	DB	0daH
	DB	04eH
	DB	0fbH
	DB	078H
	DB	0ddH
	DB	05H
	DB	0a4H
	DB	06cH
	DB	010H
	DB	0a0H
	DB	062H
	DB	05eH
	DB	09bH
	DB	0b0H
	DB	0e5H
	DB	09fH
	DB	041H
	DB	0feH
	DB	01eH
	DB	0e7H
	DB	09cH
	DB	0fbH
	DB	0baH
	DB	08bH
	DB	08cH
?AesKeyV4@@3QBEB DB 05H					; AesKeyV4
	DB	03dH
	DB	083H
	DB	07H
	DB	0f9H
	DB	0e5H
	DB	0f0H
	DB	088H
	DB	0ebH
	DB	05eH
	DB	0a6H
	DB	068H
	DB	06cH
	DB	0f0H
	DB	037H
	DB	0c7H
	DB	0e4H
	DB	0efH
	DB	0d2H
	DB	0d6H
	DB	0dbH
	DB	088H
	DB	075H
	DB	06eH
	DB	022H
	DB	06dH
	DB	085H
	DB	0e6H
	DB	0c9H
	DB	033H
	DB	023H
	DB	08eH
	DB	0a5H
	DB	0c3H
	DB	014H
	DB	049H
	DB	041H
	DB	02cH
	DB	0c6H
	DB	09fH
	DB	0a8H
	DB	03cH
	DB	0aeH
	DB	0edH
	DB	08aH
	DB	051H
	DB	02bH
	DB	0bH
	DB	043H
	DB	062H
	DB	08H
	DB	085H
	DB	0e6H
	DB	0a1H
	DB	01cH
	DB	0ccH
	DB	0a7H
	DB	08dH
	DB	0daH
	DB	053H
	DB	0f1H
	DB	06bH
	DB	043H
	DB	0b1H
	DB	07bH
	DB	03aH
	DB	068H
	DB	0baH
	DB	038H
	DB	058H
	DB	060H
	DB	03fH
	DB	0deH
	DB	0f9H
	DB	07cH
	DB	0f3H
	DB	079H
	DB	074H
	DB	0a6H
	DB	0a0H
	DB	06bH
	DB	04fH
	DB	0a3H
	DB	07H
	DB	010H
	DB	075H
	DB	0cbH
	DB	0bdH
	DB	028H
	DB	02dH
	DB	0abH
	DB	082H
	DB	0f6H
	DB	0d4H
	DB	0d7H
	DB	071H
	DB	08fH
	DB	0a0H
	DB	071H
	DB	0d1H
	DB	09bH
	DB	0ecH
	DB	09dH
	DB	074H
	DB	08bH
	DB	099H
	DB	056H
	DB	0c9H
	DB	0a3H
	DB	0b4H
	DB	0fdH
	DB	04bH
	DB	055H
	DB	060H
	DB	02aH
	DB	03aH
	DB	0daH
	DB	0c0H
	DB	05bH
	DB	0ebH
	DB	01H
	DB	0d5H
	DB	074H
	DB	023H
	DB	08aH
	DB	04cH
	DB	022H
	DB	0eaH
	DB	029H
	DB	0f8H
	DB	0dfH
	DB	0a1H
	DB	07cH
	DB	098H
	DB	0f5H
	DB	09bH
	DB	0a6H
	DB	058H
	DB	0aeH
	DB	070H
	DB	02bH
	DB	031H
	DB	025H
	DB	07H
	DB	0a1H
	DB	07dH
	DB	07H
	DB	0edH
	DB	088H
	DB	085H
	DB	0d8H
	DB	04cH
	DB	0f4H
	DB	01dH
	DB	02dH
	DB	0d7H
	DB	052H
	DB	045H
	DB	083H
	DB	0a7H
	DB	0c5H
	DB	0ddH
	DB	079H
	DB	07H
	DB	064H
	DB	0a0H
	DB	07eH
	DB	0eaH
	DB	0ecH
	DB	025H
	DB	0a6H
	DB	0a6H
	DB	018H
	DB	038H
	DB	08bH
	DB	071H
	DB	04aH
	DB	07dH
	DB	08H
	DB	0d6H
	DB	021H
	DB	0edH
	DB	08fH
	DB	0d1H
	DB	045H
	DB	04dH
	DB	0f1H
	DB	03bH
	DB	0a9H
	DB	068H
	DB	057H
	DB	09dH
CONST	ENDS
PUBLIC	?AesEncryptMessageV5@@YGHPBEPAEPAKK@Z		; AesEncryptMessageV5
PUBLIC	?AesDecryptMessageV5@@YGHPBEPAEPAK@Z		; AesDecryptMessageV5
PUBLIC	?XorBuffer@@YGXPBEPAE@Z				; XorBuffer
PUBLIC	?SubBytes@@YGXPAE@Z				; SubBytes
PUBLIC	?InvSubBytes@@YGXPAE@Z				; InvSubBytes
PUBLIC	?ShiftRows@@YGXPAE@Z				; ShiftRows
PUBLIC	?InvShiftRows@@YGXPAE@Z				; InvShiftRows
PUBLIC	?MixColumns@@YGXPAE@Z				; MixColumns
PUBLIC	?InvMixColumns@@YGXPAE@Z			; InvMixColumns
PUBLIC	?AesEncryptBlock@@YGXPAEPBE@Z			; AesEncryptBlock
PUBLIC	?AesDecryptBlock@@YGXPAEPBE@Z			; AesDecryptBlock
PUBLIC	?AesEncryptMessageV6@@YGHPBEPAEPAKK@Z		; AesEncryptMessageV6
PUBLIC	?AesDecryptMessageV6@@YGHPBEPAEPAK@Z		; AesDecryptMessageV6
PUBLIC	?Hash@@YGXPBEPAE@Z				; Hash
PUBLIC	?GetV4Cmac@@YGXHPBEPAE@Z			; GetV4Cmac
PUBLIC	?GetSha256Hash@@YGHPBEKPAE@Z			; GetSha256Hash
PUBLIC	?GetHmacKey@@YGXPB_KPAE@Z			; GetHmacKey
PUBLIC	?GetHmacSha256@@YGHPBEK0PAE@Z			; GetHmacSha256
PUBLIC	?GetRandomBytes@@YGHPAEK@Z			; GetRandomBytes
PUBLIC	?AesEncryptMessage@@YGHKPBEPAEPAKK@Z		; AesEncryptMessage
PUBLIC	?AesDecryptMessage@@YGHKPBEPAEPAK@Z		; AesDecryptMessage
PUBLIC	__JustMyCode_Default
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__CryptAcquireContextW@20:PROC
EXTRN	__imp__CryptReleaseContext@8:PROC
EXTRN	__imp__CryptDestroyKey@4:PROC
EXTRN	__imp__CryptSetKeyParam@16:PROC
EXTRN	__imp__CryptSetHashParam@16:PROC
EXTRN	__imp__CryptGetHashParam@20:PROC
EXTRN	__imp__CryptGenRandom@12:PROC
EXTRN	__imp__CryptImportKey@24:PROC
EXTRN	__imp__CryptEncrypt@28:PROC
EXTRN	__imp__CryptDecrypt@24:PROC
EXTRN	__imp__CryptCreateHash@20:PROC
EXTRN	__imp__CryptHashData@16:PROC
EXTRN	__imp__CryptDestroyHash@4:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__allmul:PROC
EXTRN	__aulldiv:PROC
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?AesDecryptMessage@@YGHKPBEPAEPAK@Z
_TEXT	SEGMENT
tv64 = -68						; size = 4
_Version$ = 8						; size = 4
_IV$ = 12						; size = 4
_Message$ = 16						; size = 4
_MessageSize$ = 20					; size = 4
?AesDecryptMessage@@YGHKPBEPAEPAK@Z PROC		; AesDecryptMessage, COMDAT

; 509  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 510  : 	switch (Version)

  00013	8b 45 08	 mov	 eax, DWORD PTR _Version$[ebp]
  00016	89 45 bc	 mov	 DWORD PTR tv64[ebp], eax
  00019	81 7d bc 00 00
	05 00		 cmp	 DWORD PTR tv64[ebp], 327680 ; 00050000H
  00020	74 0b		 je	 SHORT $LN4@AesDecrypt
  00022	81 7d bc 00 00
	06 00		 cmp	 DWORD PTR tv64[ebp], 393216 ; 00060000H
  00029	74 17		 je	 SHORT $LN5@AesDecrypt
  0002b	eb 2a		 jmp	 SHORT $LN6@AesDecrypt
$LN4@AesDecrypt:

; 511  : 	{
; 512  : 	case 0x00050000:
; 513  : 		return AesDecryptMessageV5(IV, Message, MessageSize);

  0002d	8b 45 14	 mov	 eax, DWORD PTR _MessageSize$[ebp]
  00030	50		 push	 eax
  00031	8b 4d 10	 mov	 ecx, DWORD PTR _Message$[ebp]
  00034	51		 push	 ecx
  00035	8b 55 0c	 mov	 edx, DWORD PTR _IV$[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?AesDecryptMessageV5@@YGHPBEPAEPAK@Z ; AesDecryptMessageV5
  0003e	eb 19		 jmp	 SHORT $LN1@AesDecrypt

; 514  : 		break;

  00040	eb 17		 jmp	 SHORT $LN1@AesDecrypt
$LN5@AesDecrypt:

; 515  : 
; 516  : 	case 0x00060000:
; 517  : 		return AesDecryptMessageV6(IV, Message, MessageSize);

  00042	8b 45 14	 mov	 eax, DWORD PTR _MessageSize$[ebp]
  00045	50		 push	 eax
  00046	8b 4d 10	 mov	 ecx, DWORD PTR _Message$[ebp]
  00049	51		 push	 ecx
  0004a	8b 55 0c	 mov	 edx, DWORD PTR _IV$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 ?AesDecryptMessageV6@@YGHPBEPAEPAK@Z ; AesDecryptMessageV6
  00053	eb 04		 jmp	 SHORT $LN1@AesDecrypt

; 518  : 		break;

  00055	eb 02		 jmp	 SHORT $LN1@AesDecrypt
$LN6@AesDecrypt:

; 519  : 
; 520  : 	default:
; 521  : 		return FALSE;

  00057	33 c0		 xor	 eax, eax
$LN1@AesDecrypt:

; 522  : 	}
; 523  : }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 10 00	 ret	 16			; 00000010H
?AesDecryptMessage@@YGHKPBEPAEPAK@Z ENDP		; AesDecryptMessage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?AesEncryptMessage@@YGHKPBEPAEPAKK@Z
_TEXT	SEGMENT
tv64 = -68						; size = 4
_Version$ = 8						; size = 4
_IV$ = 12						; size = 4
_Message$ = 16						; size = 4
_MessageSize$ = 20					; size = 4
_MessageBufLen$ = 24					; size = 4
?AesEncryptMessage@@YGHKPBEPAEPAKK@Z PROC		; AesEncryptMessage, COMDAT

; 492  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 493  : 	switch (Version)

  00013	8b 45 08	 mov	 eax, DWORD PTR _Version$[ebp]
  00016	89 45 bc	 mov	 DWORD PTR tv64[ebp], eax
  00019	81 7d bc 00 00
	05 00		 cmp	 DWORD PTR tv64[ebp], 327680 ; 00050000H
  00020	74 0b		 je	 SHORT $LN4@AesEncrypt
  00022	81 7d bc 00 00
	06 00		 cmp	 DWORD PTR tv64[ebp], 393216 ; 00060000H
  00029	74 1b		 je	 SHORT $LN5@AesEncrypt
  0002b	eb 32		 jmp	 SHORT $LN6@AesEncrypt
$LN4@AesEncrypt:

; 494  : 	{
; 495  : 	case 0x00050000:
; 496  : 		return AesEncryptMessageV5(IV, Message, MessageSize, MessageBufLen);

  0002d	8b 45 18	 mov	 eax, DWORD PTR _MessageBufLen$[ebp]
  00030	50		 push	 eax
  00031	8b 4d 14	 mov	 ecx, DWORD PTR _MessageSize$[ebp]
  00034	51		 push	 ecx
  00035	8b 55 10	 mov	 edx, DWORD PTR _Message$[ebp]
  00038	52		 push	 edx
  00039	8b 45 0c	 mov	 eax, DWORD PTR _IV$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?AesEncryptMessageV5@@YGHPBEPAEPAKK@Z ; AesEncryptMessageV5
  00042	eb 1d		 jmp	 SHORT $LN1@AesEncrypt

; 497  : 		break;

  00044	eb 1b		 jmp	 SHORT $LN1@AesEncrypt
$LN5@AesEncrypt:

; 498  : 
; 499  : 	case 0x00060000:
; 500  : 		return AesEncryptMessageV6(IV, Message, MessageSize, MessageBufLen);

  00046	8b 45 18	 mov	 eax, DWORD PTR _MessageBufLen$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d 14	 mov	 ecx, DWORD PTR _MessageSize$[ebp]
  0004d	51		 push	 ecx
  0004e	8b 55 10	 mov	 edx, DWORD PTR _Message$[ebp]
  00051	52		 push	 edx
  00052	8b 45 0c	 mov	 eax, DWORD PTR _IV$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?AesEncryptMessageV6@@YGHPBEPAEPAKK@Z ; AesEncryptMessageV6
  0005b	eb 04		 jmp	 SHORT $LN1@AesEncrypt

; 501  : 		break;

  0005d	eb 02		 jmp	 SHORT $LN1@AesEncrypt
$LN6@AesEncrypt:

; 502  : 
; 503  : 	default:
; 504  : 		return FALSE;

  0005f	33 c0		 xor	 eax, eax
$LN1@AesEncrypt:

; 505  : 	}
; 506  : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 14 00	 ret	 20			; 00000014H
?AesEncryptMessage@@YGHKPBEPAEPAKK@Z ENDP		; AesEncryptMessage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?GetRandomBytes@@YGHPAEK@Z
_TEXT	SEGMENT
tv76 = -76						; size = 4
_hProv$ = -8						; size = 4
_success$ = -4						; size = 4
_RandomBuffer$ = 8					; size = 4
_RandomBufferLength$ = 12				; size = 4
?GetRandomBytes@@YGHPAEK@Z PROC				; GetRandomBytes, COMDAT

; 475  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 476  : 	BOOL success = FALSE;

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _success$[ebp], 0

; 477  : 	HCRYPTPROV hProv = 0;

  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hProv$[ebp], 0

; 478  : 
; 479  : 	success = CryptAcquireContextW(&hProv, nullptr, nullptr, PROV_RSA_AES, CRYPT_VERIFYCONTEXT) &&

  00021	68 00 00 00 f0	 push	 -268435456		; f0000000H
  00026	6a 18		 push	 24			; 00000018H
  00028	6a 00		 push	 0
  0002a	6a 00		 push	 0
  0002c	8d 45 f8	 lea	 eax, DWORD PTR _hProv$[ebp]
  0002f	50		 push	 eax
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptAcquireContextW@20
  00036	85 c0		 test	 eax, eax
  00038	74 1f		 je	 SHORT $LN4@GetRandomB
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _RandomBuffer$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _RandomBufferLength$[ebp]
  00041	52		 push	 edx
  00042	8b 45 f8	 mov	 eax, DWORD PTR _hProv$[ebp]
  00045	50		 push	 eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptGenRandom@12
  0004c	85 c0		 test	 eax, eax
  0004e	74 09		 je	 SHORT $LN4@GetRandomB
  00050	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00057	eb 07		 jmp	 SHORT $LN5@GetRandomB
$LN4@GetRandomB:
  00059	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN5@GetRandomB:
  00060	8b 4d b4	 mov	 ecx, DWORD PTR tv76[ebp]
  00063	89 4d fc	 mov	 DWORD PTR _success$[ebp], ecx

; 480  : 		CryptGenRandom(hProv, RandomBufferLength, RandomBuffer);
; 481  : 
; 482  : 	if (hProv)

  00066	83 7d f8 00	 cmp	 DWORD PTR _hProv$[ebp], 0
  0006a	74 0c		 je	 SHORT $LN2@GetRandomB

; 483  : 		CryptReleaseContext(hProv, 0);

  0006c	6a 00		 push	 0
  0006e	8b 45 f8	 mov	 eax, DWORD PTR _hProv$[ebp]
  00071	50		 push	 eax
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptReleaseContext@8
$LN2@GetRandomB:

; 484  : 
; 485  : 	return success;

  00078	8b 45 fc	 mov	 eax, DWORD PTR _success$[ebp]

; 486  : }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 08 00	 ret	 8
?GetRandomBytes@@YGHPAEK@Z ENDP				; GetRandomBytes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?GetHmacSha256@@YGHPBEK0PAE@Z
_TEXT	SEGMENT
tv144 = -108						; size = 4
_dwHmacSize$ = -40					; size = 4
_HmacInfo$ = -36					; size = 20
_hHmacHash$ = -16					; size = 4
_hKey$ = -12						; size = 4
_hProv$ = -8						; size = 4
_success$ = -4						; size = 4
_pbKey$ = 8						; size = 4
_dwDataLen$ = 12					; size = 4
_pbData$ = 16						; size = 4
_pbHash$ = 20						; size = 4
?GetHmacSha256@@YGHPBEK0PAE@Z PROC			; GetHmacSha256, COMDAT

; 439  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 440  : 	BOOL success = FALSE;

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _success$[ebp], 0

; 441  : 	HCRYPTPROV hProv = 0;

  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hProv$[ebp], 0

; 442  : 	HCRYPTKEY hKey = 0;

  00021	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hKey$[ebp], 0

; 443  : 	HCRYPTHASH hHmacHash = 0;

  00028	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hHmacHash$[ebp], 0

; 444  : 	HMAC_INFO HmacInfo = { 0 };

  0002f	33 c0		 xor	 eax, eax
  00031	89 45 dc	 mov	 DWORD PTR _HmacInfo$[ebp], eax
  00034	89 45 e0	 mov	 DWORD PTR _HmacInfo$[ebp+4], eax
  00037	89 45 e4	 mov	 DWORD PTR _HmacInfo$[ebp+8], eax
  0003a	89 45 e8	 mov	 DWORD PTR _HmacInfo$[ebp+12], eax
  0003d	89 45 ec	 mov	 DWORD PTR _HmacInfo$[ebp+16], eax

; 445  : 	DWORD dwHmacSize = 32;

  00040	c7 45 d8 20 00
	00 00		 mov	 DWORD PTR _dwHmacSize$[ebp], 32 ; 00000020H

; 446  : 
; 447  : 	HmacInfo.HashAlgid = CALG_SHA_256;

  00047	c7 45 dc 0c 80
	00 00		 mov	 DWORD PTR _HmacInfo$[ebp], 32780 ; 0000800cH

; 448  : 
; 449  : 	if (pbKey != nullptr)

  0004e	83 7d 08 00	 cmp	 DWORD PTR _pbKey$[ebp], 0
  00052	74 13		 je	 SHORT $LN2@GetHmacSha

; 450  : 		memcpy(HmacKeyblob.rgbKeyData, pbKey, 16);

  00054	6a 10		 push	 16			; 00000010H
  00056	8b 45 08	 mov	 eax, DWORD PTR _pbKey$[ebp]
  00059	50		 push	 eax
  0005a	68 0c 00 00 00	 push	 OFFSET ?HmacKeyblob@@3UHMAC_KEYBLOB@@A+12
  0005f	e8 00 00 00 00	 call	 _memcpy
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GetHmacSha:

; 451  : 
; 452  : 	success = CryptAcquireContextW(&hProv, nullptr, nullptr, PROV_RSA_AES, CRYPT_VERIFYCONTEXT) &&

  00067	68 00 00 00 f0	 push	 -268435456		; f0000000H
  0006c	6a 18		 push	 24			; 00000018H
  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	8d 45 f8	 lea	 eax, DWORD PTR _hProv$[ebp]
  00075	50		 push	 eax
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptAcquireContextW@20
  0007c	85 c0		 test	 eax, eax
  0007e	0f 84 8b 00 00
	00		 je	 $LN7@GetHmacSha
  00084	8d 4d f4	 lea	 ecx, DWORD PTR _hKey$[ebp]
  00087	51		 push	 ecx
  00088	6a 00		 push	 0
  0008a	6a 00		 push	 0
  0008c	6a 1c		 push	 28			; 0000001cH
  0008e	68 00 00 00 00	 push	 OFFSET ?HmacKeyblob@@3UHMAC_KEYBLOB@@A ; HmacKeyblob
  00093	8b 55 f8	 mov	 edx, DWORD PTR _hProv$[ebp]
  00096	52		 push	 edx
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptImportKey@24
  0009d	85 c0		 test	 eax, eax
  0009f	74 6e		 je	 SHORT $LN7@GetHmacSha
  000a1	8d 45 f0	 lea	 eax, DWORD PTR _hHmacHash$[ebp]
  000a4	50		 push	 eax
  000a5	6a 00		 push	 0
  000a7	8b 4d f4	 mov	 ecx, DWORD PTR _hKey$[ebp]
  000aa	51		 push	 ecx
  000ab	68 09 80 00 00	 push	 32777			; 00008009H
  000b0	8b 55 f8	 mov	 edx, DWORD PTR _hProv$[ebp]
  000b3	52		 push	 edx
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptCreateHash@20
  000ba	85 c0		 test	 eax, eax
  000bc	74 51		 je	 SHORT $LN7@GetHmacSha
  000be	6a 00		 push	 0
  000c0	8d 45 dc	 lea	 eax, DWORD PTR _HmacInfo$[ebp]
  000c3	50		 push	 eax
  000c4	6a 05		 push	 5
  000c6	8b 4d f0	 mov	 ecx, DWORD PTR _hHmacHash$[ebp]
  000c9	51		 push	 ecx
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptSetHashParam@16
  000d0	85 c0		 test	 eax, eax
  000d2	74 3b		 je	 SHORT $LN7@GetHmacSha
  000d4	6a 00		 push	 0
  000d6	8b 55 0c	 mov	 edx, DWORD PTR _dwDataLen$[ebp]
  000d9	52		 push	 edx
  000da	8b 45 10	 mov	 eax, DWORD PTR _pbData$[ebp]
  000dd	50		 push	 eax
  000de	8b 4d f0	 mov	 ecx, DWORD PTR _hHmacHash$[ebp]
  000e1	51		 push	 ecx
  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptHashData@16
  000e8	85 c0		 test	 eax, eax
  000ea	74 23		 je	 SHORT $LN7@GetHmacSha
  000ec	6a 00		 push	 0
  000ee	8d 55 d8	 lea	 edx, DWORD PTR _dwHmacSize$[ebp]
  000f1	52		 push	 edx
  000f2	8b 45 14	 mov	 eax, DWORD PTR _pbHash$[ebp]
  000f5	50		 push	 eax
  000f6	6a 02		 push	 2
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR _hHmacHash$[ebp]
  000fb	51		 push	 ecx
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptGetHashParam@20
  00102	85 c0		 test	 eax, eax
  00104	74 09		 je	 SHORT $LN7@GetHmacSha
  00106	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv144[ebp], 1
  0010d	eb 07		 jmp	 SHORT $LN8@GetHmacSha
$LN7@GetHmacSha:
  0010f	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv144[ebp], 0
$LN8@GetHmacSha:
  00116	8b 55 94	 mov	 edx, DWORD PTR tv144[ebp]
  00119	89 55 fc	 mov	 DWORD PTR _success$[ebp], edx

; 453  : 		CryptImportKey(hProv, (PBYTE)&HmacKeyblob, sizeof(HMAC_KEYBLOB), 0, 0, &hKey) &&
; 454  : 		CryptCreateHash(hProv, CALG_HMAC, hKey, 0, &hHmacHash) &&
; 455  : 		CryptSetHashParam(hHmacHash, HP_HMAC_INFO, (PBYTE)&HmacInfo, 0) &&
; 456  : 		CryptHashData(hHmacHash, pbData, dwDataLen, 0) &&
; 457  : 		CryptGetHashParam(hHmacHash, HP_HASHVAL, pbHash, &dwHmacSize, 0);
; 458  : 
; 459  : 	if (hKey)

  0011c	83 7d f4 00	 cmp	 DWORD PTR _hKey$[ebp], 0
  00120	74 0a		 je	 SHORT $LN3@GetHmacSha

; 460  : 		CryptDestroyKey(hKey);

  00122	8b 45 f4	 mov	 eax, DWORD PTR _hKey$[ebp]
  00125	50		 push	 eax
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptDestroyKey@4
$LN3@GetHmacSha:

; 461  : 
; 462  : 	if (hHmacHash)

  0012c	83 7d f0 00	 cmp	 DWORD PTR _hHmacHash$[ebp], 0
  00130	74 0a		 je	 SHORT $LN4@GetHmacSha

; 463  : 		CryptDestroyHash(hHmacHash);

  00132	8b 45 f0	 mov	 eax, DWORD PTR _hHmacHash$[ebp]
  00135	50		 push	 eax
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptDestroyHash@4
$LN4@GetHmacSha:

; 464  : 
; 465  : 	if (hProv)

  0013c	83 7d f8 00	 cmp	 DWORD PTR _hProv$[ebp], 0
  00140	74 0c		 je	 SHORT $LN5@GetHmacSha

; 466  : 		CryptReleaseContext(hProv, 0);

  00142	6a 00		 push	 0
  00144	8b 45 f8	 mov	 eax, DWORD PTR _hProv$[ebp]
  00147	50		 push	 eax
  00148	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptReleaseContext@8
$LN5@GetHmacSha:

; 467  : 
; 468  : 	return success;

  0014e	8b 45 fc	 mov	 eax, DWORD PTR _success$[ebp]

; 469  : }

  00151	5f		 pop	 edi
  00152	5e		 pop	 esi
  00153	5b		 pop	 ebx
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c2 10 00	 ret	 16			; 00000010H
?GetHmacSha256@@YGHPBEK0PAE@Z ENDP			; GetHmacSha256
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?GetHmacKey@@YGXPB_KPAE@Z
_TEXT	SEGMENT
_seed$ = -40						; size = 8
_Sha256Hash$ = -32					; size = 32
_TimeStamp$ = 8						; size = 4
_Key$ = 12						; size = 4
?GetHmacKey@@YGXPB_KPAE@Z PROC				; GetHmacKey, COMDAT

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 429  : 	BYTE Sha256Hash[32];
; 430  : 	ULONG64 seed = (*TimeStamp / 0x00000022816889bdULL) * 0x000000208cbab5edULL + 0x3156cd5ac628477aULL;

  00013	8b 45 08	 mov	 eax, DWORD PTR _TimeStamp$[ebp]
  00016	6a 22		 push	 34			; 00000022H
  00018	68 bd 89 68 81	 push	 -2123855427		; 816889bdH
  0001d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00020	51		 push	 ecx
  00021	8b 10		 mov	 edx, DWORD PTR [eax]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 __aulldiv
  00029	6a 20		 push	 32			; 00000020H
  0002b	68 ed b5 ba 8c	 push	 -1933920787		; 8cbab5edH
  00030	52		 push	 edx
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 __allmul
  00037	05 7a 47 28 c6	 add	 eax, -970438790		; c628477aH
  0003c	81 d2 5a cd 56
	31		 adc	 edx, 827772250		; 3156cd5aH
  00042	89 45 d8	 mov	 DWORD PTR _seed$[ebp], eax
  00045	89 55 dc	 mov	 DWORD PTR _seed$[ebp+4], edx

; 431  : 
; 432  : 	GetSha256Hash((BYTE *)&seed, 8, Sha256Hash);

  00048	8d 45 e0	 lea	 eax, DWORD PTR _Sha256Hash$[ebp]
  0004b	50		 push	 eax
  0004c	6a 08		 push	 8
  0004e	8d 4d d8	 lea	 ecx, DWORD PTR _seed$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?GetSha256Hash@@YGHPBEKPAE@Z ; GetSha256Hash

; 433  : 
; 434  : 	memcpy(Key, &Sha256Hash[16], 16);

  00057	6a 10		 push	 16			; 00000010H
  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	c1 e0 04	 shl	 eax, 4
  00061	8d 4c 05 e0	 lea	 ecx, DWORD PTR _Sha256Hash$[ebp+eax]
  00065	51		 push	 ecx
  00066	8b 55 0c	 mov	 edx, DWORD PTR _Key$[ebp]
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 _memcpy
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 435  : }

  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
?GetHmacKey@@YGXPB_KPAE@Z ENDP				; GetHmacKey
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?GetSha256Hash@@YGHPBEKPAE@Z
_TEXT	SEGMENT
tv91 = -84						; size = 4
_HashSize$ = -16					; size = 4
_hHash$ = -12						; size = 4
_hProv$ = -8						; size = 4
_success$ = -4						; size = 4
_data$ = 8						; size = 4
_dataSize$ = 12						; size = 4
_Hash$ = 16						; size = 4
?GetSha256Hash@@YGHPBEKPAE@Z PROC			; GetSha256Hash, COMDAT

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 391  : 	BOOL success = FALSE;

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _success$[ebp], 0

; 392  : 	HCRYPTPROV hProv = 0;

  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hProv$[ebp], 0

; 393  : 	HCRYPTHASH hHash = 0;

  00021	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hHash$[ebp], 0

; 394  : 	DWORD HashSize = 32;

  00028	c7 45 f0 20 00
	00 00		 mov	 DWORD PTR _HashSize$[ebp], 32 ; 00000020H

; 395  : 
; 396  : 	success = CryptAcquireContextW(&hProv, nullptr, nullptr, PROV_RSA_AES, CRYPT_VERIFYCONTEXT) &&

  0002f	68 00 00 00 f0	 push	 -268435456		; f0000000H
  00034	6a 18		 push	 24			; 00000018H
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	8d 45 f8	 lea	 eax, DWORD PTR _hProv$[ebp]
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptAcquireContextW@20
  00044	85 c0		 test	 eax, eax
  00046	74 56		 je	 SHORT $LN5@GetSha256H
  00048	8d 4d f4	 lea	 ecx, DWORD PTR _hHash$[ebp]
  0004b	51		 push	 ecx
  0004c	6a 00		 push	 0
  0004e	6a 00		 push	 0
  00050	68 0c 80 00 00	 push	 32780			; 0000800cH
  00055	8b 55 f8	 mov	 edx, DWORD PTR _hProv$[ebp]
  00058	52		 push	 edx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptCreateHash@20
  0005f	85 c0		 test	 eax, eax
  00061	74 3b		 je	 SHORT $LN5@GetSha256H
  00063	6a 00		 push	 0
  00065	8b 45 0c	 mov	 eax, DWORD PTR _dataSize$[ebp]
  00068	50		 push	 eax
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 55 f4	 mov	 edx, DWORD PTR _hHash$[ebp]
  00070	52		 push	 edx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptHashData@16
  00077	85 c0		 test	 eax, eax
  00079	74 23		 je	 SHORT $LN5@GetSha256H
  0007b	6a 00		 push	 0
  0007d	8d 45 f0	 lea	 eax, DWORD PTR _HashSize$[ebp]
  00080	50		 push	 eax
  00081	8b 4d 10	 mov	 ecx, DWORD PTR _Hash$[ebp]
  00084	51		 push	 ecx
  00085	6a 02		 push	 2
  00087	8b 55 f4	 mov	 edx, DWORD PTR _hHash$[ebp]
  0008a	52		 push	 edx
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptGetHashParam@20
  00091	85 c0		 test	 eax, eax
  00093	74 09		 je	 SHORT $LN5@GetSha256H
  00095	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  0009c	eb 07		 jmp	 SHORT $LN6@GetSha256H
$LN5@GetSha256H:
  0009e	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
$LN6@GetSha256H:
  000a5	8b 45 ac	 mov	 eax, DWORD PTR tv91[ebp]
  000a8	89 45 fc	 mov	 DWORD PTR _success$[ebp], eax

; 397  : 		CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash) &&
; 398  : 		CryptHashData(hHash, data, dataSize, 0) &&
; 399  : 		CryptGetHashParam(hHash, HP_HASHVAL, Hash, &HashSize, 0);
; 400  : 
; 401  : 	if (hHash)

  000ab	83 7d f4 00	 cmp	 DWORD PTR _hHash$[ebp], 0
  000af	74 0a		 je	 SHORT $LN2@GetSha256H

; 402  : 		CryptDestroyHash(hHash);

  000b1	8b 45 f4	 mov	 eax, DWORD PTR _hHash$[ebp]
  000b4	50		 push	 eax
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptDestroyHash@4
$LN2@GetSha256H:

; 403  : 	if (hProv)

  000bb	83 7d f8 00	 cmp	 DWORD PTR _hProv$[ebp], 0
  000bf	74 0c		 je	 SHORT $LN3@GetSha256H

; 404  : 		CryptReleaseContext(hProv, 0);

  000c1	6a 00		 push	 0
  000c3	8b 45 f8	 mov	 eax, DWORD PTR _hProv$[ebp]
  000c6	50		 push	 eax
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptReleaseContext@8
$LN3@GetSha256H:

; 405  : 
; 406  : 	return success;

  000cd	8b 45 fc	 mov	 eax, DWORD PTR _success$[ebp]

; 407  : }

  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c2 0c 00	 ret	 12			; 0000000cH
?GetSha256Hash@@YGHPBEKPAE@Z ENDP			; GetSha256Hash
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?GetV4Cmac@@YGXHPBEPAE@Z
_TEXT	SEGMENT
_i$1 = -36						; size = 4
_lastblock$ = -32					; size = 16
_hash$ = -16						; size = 16
_MessageSize$ = 8					; size = 4
_Message$ = 12						; size = 4
_HashOut$ = 16						; size = 4
?GetV4Cmac@@YGXHPBEPAE@Z PROC				; GetV4Cmac, COMDAT

; 369  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 370  : 	BYTE hash[16] = { 0 };

  00013	33 c0		 xor	 eax, eax
  00015	89 45 f0	 mov	 DWORD PTR _hash$[ebp], eax
  00018	89 45 f4	 mov	 DWORD PTR _hash$[ebp+4], eax
  0001b	89 45 f8	 mov	 DWORD PTR _hash$[ebp+8], eax
  0001e	89 45 fc	 mov	 DWORD PTR _hash$[ebp+12], eax

; 371  : 	BYTE lastblock[16] = { 0 };

  00021	33 c0		 xor	 eax, eax
  00023	89 45 e0	 mov	 DWORD PTR _lastblock$[ebp], eax
  00026	89 45 e4	 mov	 DWORD PTR _lastblock$[ebp+4], eax
  00029	89 45 e8	 mov	 DWORD PTR _lastblock$[ebp+8], eax
  0002c	89 45 ec	 mov	 DWORD PTR _lastblock$[ebp+12], eax

; 372  : 
; 373  : 	for (; MessageSize >= 16; Message += 16, MessageSize -= 16)

  0002f	eb 12		 jmp	 SHORT $LN4@GetV4Cmac
$LN2@GetV4Cmac:
  00031	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  00034	83 c0 10	 add	 eax, 16			; 00000010H
  00037	89 45 0c	 mov	 DWORD PTR _Message$[ebp], eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _MessageSize$[ebp]
  0003d	83 e9 10	 sub	 ecx, 16			; 00000010H
  00040	89 4d 08	 mov	 DWORD PTR _MessageSize$[ebp], ecx
$LN4@GetV4Cmac:
  00043	83 7d 08 10	 cmp	 DWORD PTR _MessageSize$[ebp], 16 ; 00000010H
  00047	7c 0f		 jl	 SHORT $LN3@GetV4Cmac

; 374  : 		Hash(Message, hash);

  00049	8d 45 f0	 lea	 eax, DWORD PTR _hash$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _Message$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ?Hash@@YGXPBEPAE@Z	; Hash
  00056	eb d9		 jmp	 SHORT $LN2@GetV4Cmac
$LN3@GetV4Cmac:

; 375  : 
; 376  : 	for (int i = 0; i < MessageSize; i++)

  00058	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0005f	eb 09		 jmp	 SHORT $LN7@GetV4Cmac
$LN5@GetV4Cmac:
  00061	8b 45 dc	 mov	 eax, DWORD PTR _i$1[ebp]
  00064	83 c0 01	 add	 eax, 1
  00067	89 45 dc	 mov	 DWORD PTR _i$1[ebp], eax
$LN7@GetV4Cmac:
  0006a	8b 45 dc	 mov	 eax, DWORD PTR _i$1[ebp]
  0006d	3b 45 08	 cmp	 eax, DWORD PTR _MessageSize$[ebp]
  00070	7d 11		 jge	 SHORT $LN6@GetV4Cmac

; 377  : 		lastblock[i] = Message[i];

  00072	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  00075	03 45 dc	 add	 eax, DWORD PTR _i$1[ebp]
  00078	8b 4d dc	 mov	 ecx, DWORD PTR _i$1[ebp]
  0007b	8a 10		 mov	 dl, BYTE PTR [eax]
  0007d	88 54 0d e0	 mov	 BYTE PTR _lastblock$[ebp+ecx], dl
  00081	eb de		 jmp	 SHORT $LN5@GetV4Cmac
$LN6@GetV4Cmac:

; 378  : 	lastblock[MessageSize] = 0x80;

  00083	8b 45 08	 mov	 eax, DWORD PTR _MessageSize$[ebp]
  00086	c6 44 05 e0 80	 mov	 BYTE PTR _lastblock$[ebp+eax], 128 ; 00000080H

; 379  : 	Hash(lastblock, hash);

  0008b	8d 45 f0	 lea	 eax, DWORD PTR _hash$[ebp]
  0008e	50		 push	 eax
  0008f	8d 4d e0	 lea	 ecx, DWORD PTR _lastblock$[ebp]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 ?Hash@@YGXPBEPAE@Z	; Hash

; 380  : 
; 381  : 	memcpy(HashOut, hash, 16);

  00098	6a 10		 push	 16			; 00000010H
  0009a	8d 45 f0	 lea	 eax, DWORD PTR _hash$[ebp]
  0009d	50		 push	 eax
  0009e	8b 4d 10	 mov	 ecx, DWORD PTR _HashOut$[ebp]
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 _memcpy
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 382  : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c2 0c 00	 ret	 12			; 0000000cH
?GetV4Cmac@@YGXHPBEPAE@Z ENDP				; GetV4Cmac
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?Hash@@YGXPBEPAE@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_message$ = 8						; size = 4
_hash$ = 12						; size = 4
?Hash@@YGXPBEPAE@Z PROC					; Hash, COMDAT

; 349  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 350  : 	XorBuffer(message, hash);

  00013	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _message$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer

; 351  : 
; 352  : 	AddRoundKey(hash, AesKeyV4[0]);

  00020	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp]
  00023	50		 push	 eax
  00024	b9 01 00 00 00	 mov	 ecx, 1
  00029	6b d1 00	 imul	 edx, ecx, 0
  0002c	81 c2 00 00 00
	00		 add	 edx, OFFSET ?AesKeyV4@@3QBEB
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer

; 353  : 
; 354  : 	for (DWORD i = 1; i < 11; i++)

  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 1
  0003f	eb 09		 jmp	 SHORT $LN4@Hash
$LN2@Hash:
  00041	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Hash:
  0004a	83 7d fc 0b	 cmp	 DWORD PTR _i$1[ebp], 11	; 0000000bH
  0004e	73 33		 jae	 SHORT $LN3@Hash

; 355  : 	{
; 356  : 		SubBytes(hash);

  00050	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?SubBytes@@YGXPAE@Z	; SubBytes

; 357  : 		ShiftRows(hash);

  00059	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?ShiftRows@@YGXPAE@Z	; ShiftRows

; 358  : 		MixColumns(hash);

  00062	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?MixColumns@@YGXPAE@Z	; MixColumns

; 359  : 		AddRoundKey(hash, AesKeyV4[i << 4]);

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _i$1[ebp]
  00072	c1 e1 04	 shl	 ecx, 4
  00075	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?AesKeyV4@@3QBEB
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer

; 360  : 	}

  00081	eb be		 jmp	 SHORT $LN2@Hash
$LN3@Hash:

; 361  : 
; 362  : 	SubBytes(hash);

  00083	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ?SubBytes@@YGXPAE@Z	; SubBytes

; 363  : 	ShiftRows(hash);

  0008c	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?ShiftRows@@YGXPAE@Z	; ShiftRows

; 364  : 	AddRoundKey(hash, AesKeyV4[11 << 4]);

  00095	8b 45 0c	 mov	 eax, DWORD PTR _hash$[ebp]
  00098	50		 push	 eax
  00099	b9 01 00 00 00	 mov	 ecx, 1
  0009e	69 d1 b0 00 00
	00		 imul	 edx, ecx, 176
  000a4	81 c2 00 00 00
	00		 add	 edx, OFFSET ?AesKeyV4@@3QBEB
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer

; 365  : }

  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 08 00	 ret	 8
?Hash@@YGXPBEPAE@Z ENDP					; Hash
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?AesDecryptMessageV6@@YGHPBEPAEPAK@Z
_TEXT	SEGMENT
tv131 = -96						; size = 4
tv130 = -92						; size = 4
_i$1 = -24						; size = 4
_PaddingCount$ = -20					; size = 4
_Padding$ = -16						; size = 4
_p$ = -12						; size = 4
_block$2 = -8						; size = 4
_PlainTextLen$ = -4					; size = 4
_IV$ = 8						; size = 4
_Message$ = 12						; size = 4
_MessageSize$ = 16					; size = 4
?AesDecryptMessageV6@@YGHPBEPAEPAK@Z PROC		; AesDecryptMessageV6, COMDAT

; 283  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 284  : 	if (*MessageSize & 0xf)

  00013	8b 45 10	 mov	 eax, DWORD PTR _MessageSize$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0001b	74 07		 je	 SHORT $LN8@AesDecrypt

; 285  : 		return FALSE;

  0001d	33 c0		 xor	 eax, eax
  0001f	e9 15 01 00 00	 jmp	 $LN1@AesDecrypt
$LN8@AesDecrypt:

; 286  : 
; 287  : 	int PlainTextLen = *MessageSize;

  00024	8b 45 10	 mov	 eax, DWORD PTR _MessageSize$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d fc	 mov	 DWORD PTR _PlainTextLen$[ebp], ecx

; 288  : 
; 289  : 	for (BYTE *block = Message + PlainTextLen - AES_BLOCK_BYTES; block > Message; block -= AES_BLOCK_BYTES)

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _PlainTextLen$[ebp]
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _Message$[ebp]
  00032	8d 54 01 f0	 lea	 edx, DWORD PTR [ecx+eax-16]
  00036	89 55 f8	 mov	 DWORD PTR _block$2[ebp], edx
  00039	eb 09		 jmp	 SHORT $LN4@AesDecrypt
$LN2@AesDecrypt:
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _block$2[ebp]
  0003e	83 e8 10	 sub	 eax, 16			; 00000010H
  00041	89 45 f8	 mov	 DWORD PTR _block$2[ebp], eax
$LN4@AesDecrypt:
  00044	8b 45 f8	 mov	 eax, DWORD PTR _block$2[ebp]
  00047	3b 45 0c	 cmp	 eax, DWORD PTR _Message$[ebp]
  0004a	76 20		 jbe	 SHORT $LN3@AesDecrypt

; 290  : 	{
; 291  : 		AesDecryptBlock(block, AesKeyV6);

  0004c	68 00 00 00 00	 push	 OFFSET ?AesKeyV6@@3QBEB
  00051	8b 45 f8	 mov	 eax, DWORD PTR _block$2[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?AesDecryptBlock@@YGXPAEPBE@Z ; AesDecryptBlock

; 292  : 		XorBuffer(block - AES_BLOCK_BYTES, block);

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _block$2[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d f8	 mov	 ecx, DWORD PTR _block$2[ebp]
  00061	83 e9 10	 sub	 ecx, 16			; 00000010H
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer

; 293  : 	}

  0006a	eb cf		 jmp	 SHORT $LN2@AesDecrypt
$LN3@AesDecrypt:

; 294  : 
; 295  : 	AesDecryptBlock(Message, AesKeyV6);

  0006c	68 00 00 00 00	 push	 OFFSET ?AesKeyV6@@3QBEB
  00071	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?AesDecryptBlock@@YGXPAEPBE@Z ; AesDecryptBlock

; 296  : 
; 297  : 	if (IV != nullptr)

  0007a	83 7d 08 00	 cmp	 DWORD PTR _IV$[ebp], 0
  0007e	74 0d		 je	 SHORT $LN9@AesDecrypt

; 298  : 		XorBuffer(IV, Message);

  00080	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  00083	50		 push	 eax
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _IV$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer
$LN9@AesDecrypt:

; 299  : 
; 300  : 	if (PlainTextLen == 16 || Message[PlainTextLen - 1] > 16)

  0008d	83 7d fc 10	 cmp	 DWORD PTR _PlainTextLen$[ebp], 16 ; 00000010H
  00091	74 0f		 je	 SHORT $LN11@AesDecrypt
  00093	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  00096	03 45 fc	 add	 eax, DWORD PTR _PlainTextLen$[ebp]
  00099	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  0009d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000a0	7e 12		 jle	 SHORT $LN10@AesDecrypt
$LN11@AesDecrypt:

; 301  : 	{
; 302  : 		(*MessageSize) = PlainTextLen;

  000a2	8b 45 10	 mov	 eax, DWORD PTR _MessageSize$[ebp]
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _PlainTextLen$[ebp]
  000a8	89 08		 mov	 DWORD PTR [eax], ecx

; 303  : 		return TRUE;

  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	e9 85 00 00 00	 jmp	 $LN1@AesDecrypt
$LN10@AesDecrypt:

; 304  : 	}
; 305  : 
; 306  : 	const BYTE *p = &Message[PlainTextLen - 1];

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _PlainTextLen$[ebp]
  000b7	8b 4d 0c	 mov	 ecx, DWORD PTR _Message$[ebp]
  000ba	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  000be	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx

; 307  : 	int Padding = Message[PlainTextLen - 1];

  000c1	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  000c4	03 45 fc	 add	 eax, DWORD PTR _PlainTextLen$[ebp]
  000c7	0f b6 48 ff	 movzx	 ecx, BYTE PTR [eax-1]
  000cb	89 4d f0	 mov	 DWORD PTR _Padding$[ebp], ecx

; 308  : 	int PaddingCount = 0;

  000ce	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _PaddingCount$[ebp], 0

; 309  : 
; 310  : 	for (int i = Padding; i > 0; i--)

  000d5	8b 45 f0	 mov	 eax, DWORD PTR _Padding$[ebp]
  000d8	89 45 e8	 mov	 DWORD PTR _i$1[ebp], eax
  000db	eb 09		 jmp	 SHORT $LN7@AesDecrypt
$LN5@AesDecrypt:
  000dd	8b 45 e8	 mov	 eax, DWORD PTR _i$1[ebp]
  000e0	83 e8 01	 sub	 eax, 1
  000e3	89 45 e8	 mov	 DWORD PTR _i$1[ebp], eax
$LN7@AesDecrypt:
  000e6	83 7d e8 00	 cmp	 DWORD PTR _i$1[ebp], 0
  000ea	7e 2f		 jle	 SHORT $LN6@AesDecrypt

; 311  : 	{
; 312  : 		if ((*p--) != Padding)

  000ec	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  000ef	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000f2	89 4d a4	 mov	 DWORD PTR tv130[ebp], ecx
  000f5	8b 55 f0	 mov	 edx, DWORD PTR _Padding$[ebp]
  000f8	89 55 a0	 mov	 DWORD PTR tv131[ebp], edx
  000fb	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  000fe	83 e8 01	 sub	 eax, 1
  00101	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
  00104	8b 4d a4	 mov	 ecx, DWORD PTR tv130[ebp]
  00107	3b 4d a0	 cmp	 ecx, DWORD PTR tv131[ebp]
  0010a	74 04		 je	 SHORT $LN12@AesDecrypt

; 313  : 			break;

  0010c	eb 0d		 jmp	 SHORT $LN6@AesDecrypt
  0010e	eb 09		 jmp	 SHORT $LN13@AesDecrypt
$LN12@AesDecrypt:

; 314  : 		else
; 315  : 			PaddingCount++;

  00110	8b 45 ec	 mov	 eax, DWORD PTR _PaddingCount$[ebp]
  00113	83 c0 01	 add	 eax, 1
  00116	89 45 ec	 mov	 DWORD PTR _PaddingCount$[ebp], eax
$LN13@AesDecrypt:

; 316  : 	}

  00119	eb c2		 jmp	 SHORT $LN5@AesDecrypt
$LN6@AesDecrypt:

; 317  : 
; 318  : 	if (PaddingCount == Padding)

  0011b	8b 45 ec	 mov	 eax, DWORD PTR _PaddingCount$[ebp]
  0011e	3b 45 f0	 cmp	 eax, DWORD PTR _Padding$[ebp]
  00121	75 09		 jne	 SHORT $LN14@AesDecrypt

; 319  : 		PlainTextLen -= Padding;

  00123	8b 45 fc	 mov	 eax, DWORD PTR _PlainTextLen$[ebp]
  00126	2b 45 f0	 sub	 eax, DWORD PTR _Padding$[ebp]
  00129	89 45 fc	 mov	 DWORD PTR _PlainTextLen$[ebp], eax
$LN14@AesDecrypt:

; 320  : 
; 321  : 	(*MessageSize) = PlainTextLen;

  0012c	8b 45 10	 mov	 eax, DWORD PTR _MessageSize$[ebp]
  0012f	8b 4d fc	 mov	 ecx, DWORD PTR _PlainTextLen$[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx

; 322  : 
; 323  : 	return TRUE;

  00134	b8 01 00 00 00	 mov	 eax, 1
$LN1@AesDecrypt:

; 324  : }

  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 0c 00	 ret	 12			; 0000000cH
?AesDecryptMessageV6@@YGHPBEPAEPAK@Z ENDP		; AesDecryptMessageV6
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?AesEncryptMessageV6@@YGHPBEPAEPAKK@Z
_TEXT	SEGMENT
_len$1 = -16						; size = 4
_CipherTextLen$ = -12					; size = 4
_Padding$ = -8						; size = 4
_PlainTextLen$ = -4					; size = 4
_IV$ = 8						; size = 4
_Message$ = 12						; size = 4
_MessageSize$ = 16					; size = 4
_BufferLen$ = 20					; size = 4
?AesEncryptMessageV6@@YGHPBEPAEPAKK@Z PROC		; AesEncryptMessageV6, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 255  : 	DWORD PlainTextLen = *MessageSize;

  00013	8b 45 10	 mov	 eax, DWORD PTR _MessageSize$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	89 4d fc	 mov	 DWORD PTR _PlainTextLen$[ebp], ecx

; 256  : 	DWORD Padding = (~PlainTextLen & 0xf) + 1;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _PlainTextLen$[ebp]
  0001e	f7 d0		 not	 eax
  00020	83 e0 0f	 and	 eax, 15			; 0000000fH
  00023	83 c0 01	 add	 eax, 1
  00026	89 45 f8	 mov	 DWORD PTR _Padding$[ebp], eax

; 257  : 	DWORD CipherTextLen = PlainTextLen + Padding;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _PlainTextLen$[ebp]
  0002c	03 45 f8	 add	 eax, DWORD PTR _Padding$[ebp]
  0002f	89 45 f4	 mov	 DWORD PTR _CipherTextLen$[ebp], eax

; 258  : 
; 259  : 	if (CipherTextLen > BufferLen)

  00032	8b 45 f4	 mov	 eax, DWORD PTR _CipherTextLen$[ebp]
  00035	3b 45 14	 cmp	 eax, DWORD PTR _BufferLen$[ebp]
  00038	76 07		 jbe	 SHORT $LN5@AesEncrypt

; 260  : 		return FALSE;

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 88 00 00 00	 jmp	 $LN1@AesEncrypt
$LN5@AesEncrypt:

; 261  : 
; 262  : 	memset(Message + PlainTextLen, Padding, Padding);

  00041	8b 45 f8	 mov	 eax, DWORD PTR _Padding$[ebp]
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _Padding$[ebp]
  00048	51		 push	 ecx
  00049	8b 55 0c	 mov	 edx, DWORD PTR _Message$[ebp]
  0004c	03 55 fc	 add	 edx, DWORD PTR _PlainTextLen$[ebp]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 _memset
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 263  : 
; 264  : 	if (IV != nullptr)

  00058	83 7d 08 00	 cmp	 DWORD PTR _IV$[ebp], 0
  0005c	74 0d		 je	 SHORT $LN6@AesEncrypt

; 265  : 		XorBuffer(IV, Message);

  0005e	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  00061	50		 push	 eax
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _IV$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer
$LN6@AesEncrypt:

; 266  : 
; 267  : 	AesEncryptBlock(Message, AesKeyV6);

  0006b	68 00 00 00 00	 push	 OFFSET ?AesKeyV6@@3QBEB
  00070	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?AesEncryptBlock@@YGXPAEPBE@Z ; AesEncryptBlock

; 268  : 
; 269  : 	for (int len = CipherTextLen - AES_BLOCK_BYTES; len; len -= AES_BLOCK_BYTES)

  00079	8b 45 f4	 mov	 eax, DWORD PTR _CipherTextLen$[ebp]
  0007c	83 e8 10	 sub	 eax, 16			; 00000010H
  0007f	89 45 f0	 mov	 DWORD PTR _len$1[ebp], eax
  00082	eb 09		 jmp	 SHORT $LN4@AesEncrypt
$LN2@AesEncrypt:
  00084	8b 45 f0	 mov	 eax, DWORD PTR _len$1[ebp]
  00087	83 e8 10	 sub	 eax, 16			; 00000010H
  0008a	89 45 f0	 mov	 DWORD PTR _len$1[ebp], eax
$LN4@AesEncrypt:
  0008d	83 7d f0 00	 cmp	 DWORD PTR _len$1[ebp], 0
  00091	74 29		 je	 SHORT $LN3@AesEncrypt

; 270  : 	{
; 271  : 		XorBuffer(Message, Message + AES_BLOCK_BYTES);

  00093	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  00096	83 c0 10	 add	 eax, 16			; 00000010H
  00099	50		 push	 eax
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR _Message$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer

; 272  : 		Message += AES_BLOCK_BYTES;

  000a3	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  000a6	83 c0 10	 add	 eax, 16			; 00000010H
  000a9	89 45 0c	 mov	 DWORD PTR _Message$[ebp], eax

; 273  : 		AesEncryptBlock(Message, AesKeyV6);

  000ac	68 00 00 00 00	 push	 OFFSET ?AesKeyV6@@3QBEB
  000b1	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ?AesEncryptBlock@@YGXPAEPBE@Z ; AesEncryptBlock

; 274  : 	}

  000ba	eb c8		 jmp	 SHORT $LN2@AesEncrypt
$LN3@AesEncrypt:

; 275  : 
; 276  : 	(*MessageSize) = CipherTextLen;

  000bc	8b 45 10	 mov	 eax, DWORD PTR _MessageSize$[ebp]
  000bf	8b 4d f4	 mov	 ecx, DWORD PTR _CipherTextLen$[ebp]
  000c2	89 08		 mov	 DWORD PTR [eax], ecx

; 277  : 
; 278  : 	return TRUE;

  000c4	b8 01 00 00 00	 mov	 eax, 1
$LN1@AesEncrypt:

; 279  : }

  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 10 00	 ret	 16			; 00000010H
?AesEncryptMessageV6@@YGHPBEPAEPAKK@Z ENDP		; AesEncryptMessageV6
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?AesDecryptBlock@@YGXPAEPBE@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_state$ = 8						; size = 4
_RoundKeys$ = 12					; size = 4
?AesDecryptBlock@@YGXPAEPBE@Z PROC			; AesDecryptBlock, COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 237  : 	AddRoundKey(state, RoundKeys[AES_ROUNDS * AES_KEY_BYTES]);

  00013	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00016	50		 push	 eax
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	69 d1 a0 00 00
	00		 imul	 edx, ecx, 160
  00022	03 55 0c	 add	 edx, DWORD PTR _RoundKeys$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer

; 238  : 
; 239  : 	for (int i = AES_ROUNDS * AES_KEY_BYTES - 16; i > 0; i -= 16)

  0002b	c7 45 fc 90 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 144 ; 00000090H
  00032	eb 09		 jmp	 SHORT $LN4@AesDecrypt
$LN2@AesDecrypt:
  00034	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00037	83 e8 10	 sub	 eax, 16			; 00000010H
  0003a	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@AesDecrypt:
  0003d	83 7d fc 00	 cmp	 DWORD PTR _i$1[ebp], 0
  00041	7e 2d		 jle	 SHORT $LN3@AesDecrypt

; 240  : 	{
; 241  : 		InvShiftRows(state);

  00043	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?InvShiftRows@@YGXPAE@Z	; InvShiftRows

; 242  : 		InvSubBytes(state);

  0004c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?InvSubBytes@@YGXPAE@Z	; InvSubBytes

; 243  : 		AddRoundKey(state, RoundKeys[i]);

  00055	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00058	50		 push	 eax
  00059	8b 4d 0c	 mov	 ecx, DWORD PTR _RoundKeys$[ebp]
  0005c	03 4d fc	 add	 ecx, DWORD PTR _i$1[ebp]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer

; 244  : 		InvMixColumns(state);

  00065	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?InvMixColumns@@YGXPAE@Z ; InvMixColumns

; 245  : 	};

  0006e	eb c4		 jmp	 SHORT $LN2@AesDecrypt
$LN3@AesDecrypt:

; 246  : 
; 247  : 	InvShiftRows(state);

  00070	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?InvShiftRows@@YGXPAE@Z	; InvShiftRows

; 248  : 	InvSubBytes(state);

  00079	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?InvSubBytes@@YGXPAE@Z	; InvSubBytes

; 249  : 	AddRoundKey(state, RoundKeys[0]);

  00082	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00085	50		 push	 eax
  00086	b9 01 00 00 00	 mov	 ecx, 1
  0008b	6b d1 00	 imul	 edx, ecx, 0
  0008e	03 55 0c	 add	 edx, DWORD PTR _RoundKeys$[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer

; 250  : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 08 00	 ret	 8
?AesDecryptBlock@@YGXPAEPBE@Z ENDP			; AesDecryptBlock
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?AesEncryptBlock@@YGXPAEPBE@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_state$ = 8						; size = 4
_RoundKeys$ = 12					; size = 4
?AesEncryptBlock@@YGXPAEPBE@Z PROC			; AesEncryptBlock, COMDAT

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 219  : 	AddRoundKey(state, RoundKeys[0]);

  00013	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00016	50		 push	 eax
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	6b d1 00	 imul	 edx, ecx, 0
  0001f	03 55 0c	 add	 edx, DWORD PTR _RoundKeys$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer

; 220  : 
; 221  : 	for (int i = 16; i < AES_ROUNDS * AES_KEY_BYTES; i += 16)

  00028	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 16	; 00000010H
  0002f	eb 09		 jmp	 SHORT $LN4@AesEncrypt
$LN2@AesEncrypt:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00034	83 c0 10	 add	 eax, 16			; 00000010H
  00037	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@AesEncrypt:
  0003a	81 7d fc a0 00
	00 00		 cmp	 DWORD PTR _i$1[ebp], 160 ; 000000a0H
  00041	7d 2d		 jge	 SHORT $LN3@AesEncrypt

; 222  : 	{
; 223  : 		SubBytes(state);

  00043	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?SubBytes@@YGXPAE@Z	; SubBytes

; 224  : 		ShiftRows(state);

  0004c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?ShiftRows@@YGXPAE@Z	; ShiftRows

; 225  : 		MixColumns(state);

  00055	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?MixColumns@@YGXPAE@Z	; MixColumns

; 226  : 		AddRoundKey(state, RoundKeys[i]);

  0005e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00061	50		 push	 eax
  00062	8b 4d 0c	 mov	 ecx, DWORD PTR _RoundKeys$[ebp]
  00065	03 4d fc	 add	 ecx, DWORD PTR _i$1[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer

; 227  : 	}

  0006e	eb c1		 jmp	 SHORT $LN2@AesEncrypt
$LN3@AesEncrypt:

; 228  : 
; 229  : 	SubBytes(state);

  00070	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?SubBytes@@YGXPAE@Z	; SubBytes

; 230  : 	ShiftRows(state);

  00079	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?ShiftRows@@YGXPAE@Z	; ShiftRows

; 231  : 	AddRoundKey(state, RoundKeys[AES_ROUNDS * AES_KEY_BYTES]);

  00082	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00085	50		 push	 eax
  00086	b9 01 00 00 00	 mov	 ecx, 1
  0008b	69 d1 a0 00 00
	00		 imul	 edx, ecx, 160
  00091	03 55 0c	 add	 edx, DWORD PTR _RoundKeys$[ebp]
  00094	52		 push	 edx
  00095	e8 00 00 00 00	 call	 ?XorBuffer@@YGXPBEPAE@Z	; XorBuffer

; 232  : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
?AesEncryptBlock@@YGXPAEPBE@Z ENDP			; AesEncryptBlock
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?InvMixColumns@@YGXPAE@Z
_TEXT	SEGMENT
_g_mulC$1 = -28						; size = 4
_g_mul9$2 = -24						; size = 4
_g_mul8$3 = -20						; size = 4
_g_mul4$4 = -16						; size = 4
_g_mul2$5 = -12						; size = 4
_word$6 = -8						; size = 4
_i$7 = -4						; size = 4
_state$ = 8						; size = 4
?InvMixColumns@@YGXPAE@Z PROC				; InvMixColumns, COMDAT

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 203  : 	for (int i = 0; i < AES_BLOCK_WORDS; i++)

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$7[ebp], 0
  0001a	eb 09		 jmp	 SHORT $LN4@InvMixColu
$LN2@InvMixColu:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _i$7[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 fc	 mov	 DWORD PTR _i$7[ebp], eax
$LN4@InvMixColu:
  00025	83 7d fc 04	 cmp	 DWORD PTR _i$7[ebp], 4
  00029	0f 8d c8 00 00
	00		 jge	 $LN1@InvMixColu

; 204  : 	{
; 205  : 		DWORD word = ((DWORD *)state)[i];

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _i$7[ebp]
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00035	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00038	89 55 f8	 mov	 DWORD PTR _word$6[ebp], edx

; 206  : 		DWORD g_mul2 = MULx2(word);

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _word$6[ebp]
  0003e	25 7f 7f 7f 7f	 and	 eax, 2139062143		; 7f7f7f7fH
  00043	d1 e0		 shl	 eax, 1
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _word$6[ebp]
  00048	81 e1 80 80 80
	80		 and	 ecx, -2139062144	; 80808080H
  0004e	c1 e9 07	 shr	 ecx, 7
  00051	6b d1 1b	 imul	 edx, ecx, 27
  00054	33 c2		 xor	 eax, edx
  00056	89 45 f4	 mov	 DWORD PTR _g_mul2$5[ebp], eax

; 207  : 		DWORD g_mul4 = MULx2(g_mul2);

  00059	8b 45 f4	 mov	 eax, DWORD PTR _g_mul2$5[ebp]
  0005c	25 7f 7f 7f 7f	 and	 eax, 2139062143		; 7f7f7f7fH
  00061	d1 e0		 shl	 eax, 1
  00063	8b 4d f4	 mov	 ecx, DWORD PTR _g_mul2$5[ebp]
  00066	81 e1 80 80 80
	80		 and	 ecx, -2139062144	; 80808080H
  0006c	c1 e9 07	 shr	 ecx, 7
  0006f	6b d1 1b	 imul	 edx, ecx, 27
  00072	33 c2		 xor	 eax, edx
  00074	89 45 f0	 mov	 DWORD PTR _g_mul4$4[ebp], eax

; 208  : 		DWORD g_mul8 = MULx2(g_mul4);

  00077	8b 45 f0	 mov	 eax, DWORD PTR _g_mul4$4[ebp]
  0007a	25 7f 7f 7f 7f	 and	 eax, 2139062143		; 7f7f7f7fH
  0007f	d1 e0		 shl	 eax, 1
  00081	8b 4d f0	 mov	 ecx, DWORD PTR _g_mul4$4[ebp]
  00084	81 e1 80 80 80
	80		 and	 ecx, -2139062144	; 80808080H
  0008a	c1 e9 07	 shr	 ecx, 7
  0008d	6b d1 1b	 imul	 edx, ecx, 27
  00090	33 c2		 xor	 eax, edx
  00092	89 45 ec	 mov	 DWORD PTR _g_mul8$3[ebp], eax

; 209  : 		DWORD g_mul9 = g_mul8 ^ word;

  00095	8b 45 ec	 mov	 eax, DWORD PTR _g_mul8$3[ebp]
  00098	33 45 f8	 xor	 eax, DWORD PTR _word$6[ebp]
  0009b	89 45 e8	 mov	 DWORD PTR _g_mul9$2[ebp], eax

; 210  : 		DWORD g_mulC = g_mul8 ^ g_mul4;

  0009e	8b 45 ec	 mov	 eax, DWORD PTR _g_mul8$3[ebp]
  000a1	33 45 f0	 xor	 eax, DWORD PTR _g_mul4$4[ebp]
  000a4	89 45 e4	 mov	 DWORD PTR _g_mulC$1[ebp], eax

; 211  : 
; 212  : 		((DWORD *)state)[i] = g_mulC ^ g_mul2 ^ ROR32(g_mul9 ^ g_mul2, 8) ^ ROR32(g_mulC ^ word, 16) ^ ROR32(g_mul9, 24);

  000a7	8b 45 e4	 mov	 eax, DWORD PTR _g_mulC$1[ebp]
  000aa	33 45 f4	 xor	 eax, DWORD PTR _g_mul2$5[ebp]
  000ad	8b 4d e8	 mov	 ecx, DWORD PTR _g_mul9$2[ebp]
  000b0	33 4d f4	 xor	 ecx, DWORD PTR _g_mul2$5[ebp]
  000b3	c1 e1 18	 shl	 ecx, 24			; 00000018H
  000b6	8b 55 e8	 mov	 edx, DWORD PTR _g_mul9$2[ebp]
  000b9	33 55 f4	 xor	 edx, DWORD PTR _g_mul2$5[ebp]
  000bc	c1 ea 08	 shr	 edx, 8
  000bf	0b ca		 or	 ecx, edx
  000c1	33 c1		 xor	 eax, ecx
  000c3	8b 4d e4	 mov	 ecx, DWORD PTR _g_mulC$1[ebp]
  000c6	33 4d f8	 xor	 ecx, DWORD PTR _word$6[ebp]
  000c9	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000cc	8b 55 e4	 mov	 edx, DWORD PTR _g_mulC$1[ebp]
  000cf	33 55 f8	 xor	 edx, DWORD PTR _word$6[ebp]
  000d2	c1 ea 10	 shr	 edx, 16			; 00000010H
  000d5	0b ca		 or	 ecx, edx
  000d7	33 c1		 xor	 eax, ecx
  000d9	8b 4d e8	 mov	 ecx, DWORD PTR _g_mul9$2[ebp]
  000dc	c1 e1 08	 shl	 ecx, 8
  000df	8b 55 e8	 mov	 edx, DWORD PTR _g_mul9$2[ebp]
  000e2	c1 ea 18	 shr	 edx, 24			; 00000018H
  000e5	0b ca		 or	 ecx, edx
  000e7	33 c1		 xor	 eax, ecx
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _i$7[ebp]
  000ec	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000ef	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 213  : 	}

  000f2	e9 25 ff ff ff	 jmp	 $LN2@InvMixColu
$LN1@InvMixColu:

; 214  : }

  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
?InvMixColumns@@YGXPAE@Z ENDP				; InvMixColumns
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?MixColumns@@YGXPAE@Z
_TEXT	SEGMENT
_g_mul2$1 = -12						; size = 4
_word$2 = -8						; size = 4
_i$3 = -4						; size = 4
_state$ = 8						; size = 4
?MixColumns@@YGXPAE@Z PROC				; MixColumns, COMDAT

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 191  : 	for (int i = 0; i < AES_BLOCK_WORDS; i++)

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  0001a	eb 09		 jmp	 SHORT $LN4@MixColumns
$LN2@MixColumns:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _i$3[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 fc	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@MixColumns:
  00025	83 7d fc 04	 cmp	 DWORD PTR _i$3[ebp], 4
  00029	7d 6c		 jge	 SHORT $LN1@MixColumns

; 192  : 	{
; 193  : 		DWORD word = ((DWORD *)state)[i];

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _i$3[ebp]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00031	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00034	89 55 f8	 mov	 DWORD PTR _word$2[ebp], edx

; 194  : 		DWORD g_mul2 = MULx2(word);

  00037	8b 45 f8	 mov	 eax, DWORD PTR _word$2[ebp]
  0003a	25 7f 7f 7f 7f	 and	 eax, 2139062143		; 7f7f7f7fH
  0003f	d1 e0		 shl	 eax, 1
  00041	8b 4d f8	 mov	 ecx, DWORD PTR _word$2[ebp]
  00044	81 e1 80 80 80
	80		 and	 ecx, -2139062144	; 80808080H
  0004a	c1 e9 07	 shr	 ecx, 7
  0004d	6b d1 1b	 imul	 edx, ecx, 27
  00050	33 c2		 xor	 eax, edx
  00052	89 45 f4	 mov	 DWORD PTR _g_mul2$1[ebp], eax

; 195  : 
; 196  : 		((DWORD *)state)[i] = g_mul2 ^ ROR32(g_mul2^word, 8) ^ ROR32(word, 16) ^ ROR32(word, 24);

  00055	8b 45 f4	 mov	 eax, DWORD PTR _g_mul2$1[ebp]
  00058	33 45 f8	 xor	 eax, DWORD PTR _word$2[ebp]
  0005b	c1 e0 18	 shl	 eax, 24			; 00000018H
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _g_mul2$1[ebp]
  00061	33 4d f8	 xor	 ecx, DWORD PTR _word$2[ebp]
  00064	c1 e9 08	 shr	 ecx, 8
  00067	0b c1		 or	 eax, ecx
  00069	33 45 f4	 xor	 eax, DWORD PTR _g_mul2$1[ebp]
  0006c	8b 55 f8	 mov	 edx, DWORD PTR _word$2[ebp]
  0006f	c1 e2 10	 shl	 edx, 16			; 00000010H
  00072	8b 4d f8	 mov	 ecx, DWORD PTR _word$2[ebp]
  00075	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00078	0b d1		 or	 edx, ecx
  0007a	33 c2		 xor	 eax, edx
  0007c	8b 55 f8	 mov	 edx, DWORD PTR _word$2[ebp]
  0007f	c1 e2 08	 shl	 edx, 8
  00082	8b 4d f8	 mov	 ecx, DWORD PTR _word$2[ebp]
  00085	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00088	0b d1		 or	 edx, ecx
  0008a	33 c2		 xor	 eax, edx
  0008c	8b 55 fc	 mov	 edx, DWORD PTR _i$3[ebp]
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00092	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 197  : 	}

  00095	eb 85		 jmp	 SHORT $LN2@MixColumns
$LN1@MixColumns:

; 198  : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
?MixColumns@@YGXPAE@Z ENDP				; MixColumns
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?InvShiftRows@@YGXPAE@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_b$ = -16						; size = 16
_state$ = 8						; size = 4
?InvShiftRows@@YGXPAE@Z PROC				; InvShiftRows, COMDAT

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 180  : 	BYTE b[AES_BLOCK_BYTES];
; 181  : 
; 182  : 	memcpy(b, state, AES_BLOCK_BYTES);

  00013	6a 10		 push	 16			; 00000010H
  00015	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00018	50		 push	 eax
  00019	8d 4d f0	 lea	 ecx, DWORD PTR _b$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 _memcpy
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 183  : 
; 184  : 	for (int i = 0; i < AES_BLOCK_BYTES; i++)

  00025	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0002c	eb 09		 jmp	 SHORT $LN4@InvShiftRo
$LN2@InvShiftRo:
  0002e	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00031	83 c0 01	 add	 eax, 1
  00034	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@InvShiftRo:
  00037	83 7d ec 10	 cmp	 DWORD PTR _i$1[ebp], 16	; 00000010H
  0003b	7d 1f		 jge	 SHORT $LN1@InvShiftRo

; 185  : 		state[i] = b[(i - ((i & 0x3) << 2)) & 0xf];

  0003d	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00040	83 e0 03	 and	 eax, 3
  00043	c1 e0 02	 shl	 eax, 2
  00046	8b 4d ec	 mov	 ecx, DWORD PTR _i$1[ebp]
  00049	2b c8		 sub	 ecx, eax
  0004b	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0004e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00051	03 55 ec	 add	 edx, DWORD PTR _i$1[ebp]
  00054	8a 44 0d f0	 mov	 al, BYTE PTR _b$[ebp+ecx]
  00058	88 02		 mov	 BYTE PTR [edx], al
  0005a	eb d2		 jmp	 SHORT $LN2@InvShiftRo
$LN1@InvShiftRo:

; 186  : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?InvShiftRows@@YGXPAE@Z ENDP				; InvShiftRows
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?ShiftRows@@YGXPAE@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_b$ = -16						; size = 16
_state$ = 8						; size = 4
?ShiftRows@@YGXPAE@Z PROC				; ShiftRows, COMDAT

; 168  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 169  : 	BYTE b[AES_BLOCK_BYTES];
; 170  : 
; 171  : 	memcpy(b, state, AES_BLOCK_BYTES);

  00013	6a 10		 push	 16			; 00000010H
  00015	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00018	50		 push	 eax
  00019	8d 4d f0	 lea	 ecx, DWORD PTR _b$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 _memcpy
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 172  : 
; 173  : 	for (int i = 0; i < AES_BLOCK_BYTES; i++)

  00025	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0002c	eb 09		 jmp	 SHORT $LN4@ShiftRows
$LN2@ShiftRows:
  0002e	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00031	83 c0 01	 add	 eax, 1
  00034	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@ShiftRows:
  00037	83 7d ec 10	 cmp	 DWORD PTR _i$1[ebp], 16	; 00000010H
  0003b	7d 1d		 jge	 SHORT $LN1@ShiftRows

; 174  : 		state[i] = b[(i + ((i & 0x3) << 2)) & 0xf];

  0003d	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00040	83 e0 03	 and	 eax, 3
  00043	8b 4d ec	 mov	 ecx, DWORD PTR _i$1[ebp]
  00046	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00049	83 e2 0f	 and	 edx, 15			; 0000000fH
  0004c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0004f	03 45 ec	 add	 eax, DWORD PTR _i$1[ebp]
  00052	8a 4c 15 f0	 mov	 cl, BYTE PTR _b$[ebp+edx]
  00056	88 08		 mov	 BYTE PTR [eax], cl
  00058	eb d4		 jmp	 SHORT $LN2@ShiftRows
$LN1@ShiftRows:

; 175  : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?ShiftRows@@YGXPAE@Z ENDP				; ShiftRows
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?InvSubBytes@@YGXPAE@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_state$ = 8						; size = 4
?InvSubBytes@@YGXPAE@Z PROC				; InvSubBytes, COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 162  : 	for (int i = 0; i < AES_BLOCK_BYTES; i++)

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0001a	eb 09		 jmp	 SHORT $LN4@InvSubByte
$LN2@InvSubByte:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@InvSubByte:
  00025	83 7d fc 10	 cmp	 DWORD PTR _i$1[ebp], 16	; 00000010H
  00029	7d 19		 jge	 SHORT $LN1@InvSubByte

; 163  : 		state[i] = InvSBox[state[i]];

  0002b	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002e	03 45 fc	 add	 eax, DWORD PTR _i$1[ebp]
  00031	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00034	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00037	03 55 fc	 add	 edx, DWORD PTR _i$1[ebp]
  0003a	8a 81 00 00 00
	00		 mov	 al, BYTE PTR ?InvSBox@@3QBEB[ecx]
  00040	88 02		 mov	 BYTE PTR [edx], al
  00042	eb d8		 jmp	 SHORT $LN2@InvSubByte
$LN1@InvSubByte:

; 164  : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?InvSubBytes@@YGXPAE@Z ENDP				; InvSubBytes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?SubBytes@@YGXPAE@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_state$ = 8						; size = 4
?SubBytes@@YGXPAE@Z PROC				; SubBytes, COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 155  : 	for (int i = 0; i < AES_BLOCK_BYTES; i++)

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0001a	eb 09		 jmp	 SHORT $LN4@SubBytes
$LN2@SubBytes:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SubBytes:
  00025	83 7d fc 10	 cmp	 DWORD PTR _i$1[ebp], 16	; 00000010H
  00029	7d 19		 jge	 SHORT $LN1@SubBytes

; 156  : 		state[i] = SBox[state[i]];

  0002b	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002e	03 45 fc	 add	 eax, DWORD PTR _i$1[ebp]
  00031	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00034	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00037	03 55 fc	 add	 edx, DWORD PTR _i$1[ebp]
  0003a	8a 81 00 00 00
	00		 mov	 al, BYTE PTR ?SBox@@3QBEB[ecx]
  00040	88 02		 mov	 BYTE PTR [edx], al
  00042	eb d8		 jmp	 SHORT $LN2@SubBytes
$LN1@SubBytes:

; 157  : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?SubBytes@@YGXPAE@Z ENDP				; SubBytes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?XorBuffer@@YGXPBEPAE@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_source$ = 8						; size = 4
_destination$ = 12					; size = 4
?XorBuffer@@YGXPBEPAE@Z PROC				; XorBuffer, COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 148  : 	for (int i = 0; i < AES_BLOCK_WORDS; i++)

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0001a	eb 09		 jmp	 SHORT $LN4@XorBuffer
$LN2@XorBuffer:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@XorBuffer:
  00025	83 7d fc 04	 cmp	 DWORD PTR _i$1[ebp], 4
  00029	7d 1d		 jge	 SHORT $LN1@XorBuffer

; 149  : 		((DWORD *)(destination))[i] ^= ((DWORD *)(source))[i];

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _destination$[ebp]
  00031	8b 55 fc	 mov	 edx, DWORD PTR _i$1[ebp]
  00034	8b 75 08	 mov	 esi, DWORD PTR _source$[ebp]
  00037	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0003a	33 04 96	 xor	 eax, DWORD PTR [esi+edx*4]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _i$1[ebp]
  00040	8b 55 0c	 mov	 edx, DWORD PTR _destination$[ebp]
  00043	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  00046	eb d4		 jmp	 SHORT $LN2@XorBuffer
$LN1@XorBuffer:

; 150  : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 08 00	 ret	 8
?XorBuffer@@YGXPBEPAE@Z ENDP				; XorBuffer
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?AesDecryptMessageV5@@YGHPBEPAEPAK@Z
_TEXT	SEGMENT
tv95 = -84						; size = 4
tv85 = -80						; size = 4
_hKey$ = -12						; size = 4
_hProv$ = -8						; size = 4
_success$ = -4						; size = 4
_IV$ = 8						; size = 4
_Message$ = 12						; size = 4
_MessageSize$ = 16					; size = 4
?AesDecryptMessageV5@@YGHPBEPAEPAK@Z PROC		; AesDecryptMessageV5, COMDAT

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 52   : 	BOOL success = FALSE;

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _success$[ebp], 0

; 53   : 	HCRYPTPROV hProv = 0;

  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hProv$[ebp], 0

; 54   : 	HCRYPTKEY hKey = 0;

  00021	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hKey$[ebp], 0

; 55   : 
; 56   : 	success = CryptAcquireContextW(&hProv, nullptr, nullptr, PROV_RSA_AES, CRYPT_VERIFYCONTEXT) &&

  00028	68 00 00 00 f0	 push	 -268435456		; f0000000H
  0002d	6a 18		 push	 24			; 00000018H
  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	8d 45 f8	 lea	 eax, DWORD PTR _hProv$[ebp]
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptAcquireContextW@20
  0003d	85 c0		 test	 eax, eax
  0003f	74 6c		 je	 SHORT $LN5@AesDecrypt
  00041	8d 4d f4	 lea	 ecx, DWORD PTR _hKey$[ebp]
  00044	51		 push	 ecx
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	6a 1c		 push	 28			; 0000001cH
  0004b	68 00 00 00 00	 push	 OFFSET ?AesKeyV5Blob@@3UAES_128_KEYBLOB@@B
  00050	8b 55 f8	 mov	 edx, DWORD PTR _hProv$[ebp]
  00053	52		 push	 edx
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptImportKey@24
  0005a	85 c0		 test	 eax, eax
  0005c	74 4f		 je	 SHORT $LN5@AesDecrypt
  0005e	83 7d 08 00	 cmp	 DWORD PTR _IV$[ebp], 0
  00062	74 17		 je	 SHORT $LN6@AesDecrypt
  00064	6a 00		 push	 0
  00066	8b 45 08	 mov	 eax, DWORD PTR _IV$[ebp]
  00069	50		 push	 eax
  0006a	6a 01		 push	 1
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR _hKey$[ebp]
  0006f	51		 push	 ecx
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptSetKeyParam@16
  00076	89 45 b0	 mov	 DWORD PTR tv85[ebp], eax
  00079	eb 07		 jmp	 SHORT $LN7@AesDecrypt
$LN6@AesDecrypt:
  0007b	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv85[ebp], 1
$LN7@AesDecrypt:
  00082	83 7d b0 00	 cmp	 DWORD PTR tv85[ebp], 0
  00086	74 25		 je	 SHORT $LN5@AesDecrypt
  00088	8b 55 10	 mov	 edx, DWORD PTR _MessageSize$[ebp]
  0008b	52		 push	 edx
  0008c	8b 45 0c	 mov	 eax, DWORD PTR _Message$[ebp]
  0008f	50		 push	 eax
  00090	6a 00		 push	 0
  00092	6a 01		 push	 1
  00094	6a 00		 push	 0
  00096	8b 4d f4	 mov	 ecx, DWORD PTR _hKey$[ebp]
  00099	51		 push	 ecx
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptDecrypt@24
  000a0	85 c0		 test	 eax, eax
  000a2	74 09		 je	 SHORT $LN5@AesDecrypt
  000a4	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
  000ab	eb 07		 jmp	 SHORT $LN8@AesDecrypt
$LN5@AesDecrypt:
  000ad	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
$LN8@AesDecrypt:
  000b4	8b 55 ac	 mov	 edx, DWORD PTR tv95[ebp]
  000b7	89 55 fc	 mov	 DWORD PTR _success$[ebp], edx

; 57   : 		CryptImportKey(hProv, (BYTE *)&AesKeyV5Blob, sizeof(AesKeyV5Blob), 0, 0, &hKey) &&
; 58   : 		(IV != nullptr ? CryptSetKeyParam(hKey, KP_IV, IV, 0) : TRUE) &&
; 59   : 		CryptDecrypt(hKey, 0, TRUE, 0, Message, MessageSize);
; 60   : 
; 61   : 	if (hKey)

  000ba	83 7d f4 00	 cmp	 DWORD PTR _hKey$[ebp], 0
  000be	74 0a		 je	 SHORT $LN2@AesDecrypt

; 62   : 		CryptDestroyKey(hKey);

  000c0	8b 45 f4	 mov	 eax, DWORD PTR _hKey$[ebp]
  000c3	50		 push	 eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptDestroyKey@4
$LN2@AesDecrypt:

; 63   : 	if (hProv)

  000ca	83 7d f8 00	 cmp	 DWORD PTR _hProv$[ebp], 0
  000ce	74 0c		 je	 SHORT $LN3@AesDecrypt

; 64   : 		CryptReleaseContext(hProv, 0);

  000d0	6a 00		 push	 0
  000d2	8b 45 f8	 mov	 eax, DWORD PTR _hProv$[ebp]
  000d5	50		 push	 eax
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptReleaseContext@8
$LN3@AesDecrypt:

; 65   : 
; 66   : 	return success;

  000dc	8b 45 fc	 mov	 eax, DWORD PTR _success$[ebp]

; 67   : }

  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 0c 00	 ret	 12			; 0000000cH
?AesDecryptMessageV5@@YGHPBEPAEPAK@Z ENDP		; AesDecryptMessageV5
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Users\Administrator\Documents\SppExtComObjHook-DLL-20181024\SppExtComObjHook\crypto.cpp
;	COMDAT ?AesEncryptMessageV5@@YGHPBEPAEPAKK@Z
_TEXT	SEGMENT
tv128 = -84						; size = 4
tv85 = -80						; size = 4
_hKey$ = -12						; size = 4
_hProv$ = -8						; size = 4
_success$ = -4						; size = 4
_IV$ = 8						; size = 4
_Message$ = 12						; size = 4
_MessageSize$ = 16					; size = 4
_BufferLen$ = 20					; size = 4
?AesEncryptMessageV5@@YGHPBEPAEPAKK@Z PROC		; AesEncryptMessageV5, COMDAT

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __EDBB2947_crypto@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 32   : 	BOOL success = FALSE;

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _success$[ebp], 0

; 33   : 	HCRYPTPROV hProv = 0;

  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hProv$[ebp], 0

; 34   : 	HCRYPTKEY hKey = 0;

  00021	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hKey$[ebp], 0

; 35   : 
; 36   : 	success = CryptAcquireContextW(&hProv, nullptr, nullptr, PROV_RSA_AES, CRYPT_VERIFYCONTEXT) &&

  00028	68 00 00 00 f0	 push	 -268435456		; f0000000H
  0002d	6a 18		 push	 24			; 00000018H
  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	8d 45 f8	 lea	 eax, DWORD PTR _hProv$[ebp]
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptAcquireContextW@20
  0003d	85 c0		 test	 eax, eax
  0003f	74 70		 je	 SHORT $LN5@AesEncrypt
  00041	8d 4d f4	 lea	 ecx, DWORD PTR _hKey$[ebp]
  00044	51		 push	 ecx
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	6a 1c		 push	 28			; 0000001cH
  0004b	68 00 00 00 00	 push	 OFFSET ?AesKeyV5Blob@@3UAES_128_KEYBLOB@@B
  00050	8b 55 f8	 mov	 edx, DWORD PTR _hProv$[ebp]
  00053	52		 push	 edx
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptImportKey@24
  0005a	85 c0		 test	 eax, eax
  0005c	74 53		 je	 SHORT $LN5@AesEncrypt
  0005e	83 7d 08 00	 cmp	 DWORD PTR _IV$[ebp], 0
  00062	74 17		 je	 SHORT $LN6@AesEncrypt
  00064	6a 00		 push	 0
  00066	8b 45 08	 mov	 eax, DWORD PTR _IV$[ebp]
  00069	50		 push	 eax
  0006a	6a 01		 push	 1
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR _hKey$[ebp]
  0006f	51		 push	 ecx
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptSetKeyParam@16
  00076	89 45 b0	 mov	 DWORD PTR tv85[ebp], eax
  00079	eb 07		 jmp	 SHORT $LN7@AesEncrypt
$LN6@AesEncrypt:
  0007b	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv85[ebp], 1
$LN7@AesEncrypt:
  00082	83 7d b0 00	 cmp	 DWORD PTR tv85[ebp], 0
  00086	74 29		 je	 SHORT $LN5@AesEncrypt
  00088	8b 55 14	 mov	 edx, DWORD PTR _BufferLen$[ebp]
  0008b	52		 push	 edx
  0008c	8b 45 10	 mov	 eax, DWORD PTR _MessageSize$[ebp]
  0008f	50		 push	 eax
  00090	8b 4d 0c	 mov	 ecx, DWORD PTR _Message$[ebp]
  00093	51		 push	 ecx
  00094	6a 00		 push	 0
  00096	6a 01		 push	 1
  00098	6a 00		 push	 0
  0009a	8b 55 f4	 mov	 edx, DWORD PTR _hKey$[ebp]
  0009d	52		 push	 edx
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptEncrypt@28
  000a4	85 c0		 test	 eax, eax
  000a6	74 09		 je	 SHORT $LN5@AesEncrypt
  000a8	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv128[ebp], 1
  000af	eb 07		 jmp	 SHORT $LN8@AesEncrypt
$LN5@AesEncrypt:
  000b1	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv128[ebp], 0
$LN8@AesEncrypt:
  000b8	8b 45 ac	 mov	 eax, DWORD PTR tv128[ebp]
  000bb	89 45 fc	 mov	 DWORD PTR _success$[ebp], eax

; 37   : 		CryptImportKey(hProv, (BYTE *)&AesKeyV5Blob, sizeof(AesKeyV5Blob), 0, 0, &hKey) &&
; 38   : 		(IV != nullptr ? CryptSetKeyParam(hKey, KP_IV, IV, 0) : TRUE) &&
; 39   : 		CryptEncrypt(hKey, 0, TRUE, 0, Message, MessageSize, BufferLen);
; 40   : 
; 41   : 	if (hKey)

  000be	83 7d f4 00	 cmp	 DWORD PTR _hKey$[ebp], 0
  000c2	74 0a		 je	 SHORT $LN2@AesEncrypt

; 42   : 		CryptDestroyKey(hKey);

  000c4	8b 45 f4	 mov	 eax, DWORD PTR _hKey$[ebp]
  000c7	50		 push	 eax
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptDestroyKey@4
$LN2@AesEncrypt:

; 43   : 	if (hProv)

  000ce	83 7d f8 00	 cmp	 DWORD PTR _hProv$[ebp], 0
  000d2	74 0c		 je	 SHORT $LN3@AesEncrypt

; 44   : 		CryptReleaseContext(hProv, 0);

  000d4	6a 00		 push	 0
  000d6	8b 45 f8	 mov	 eax, DWORD PTR _hProv$[ebp]
  000d9	50		 push	 eax
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptReleaseContext@8
$LN3@AesEncrypt:

; 45   : 
; 46   : 	return success;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR _success$[ebp]

; 47   : }

  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi
  000e5	5b		 pop	 ebx
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 10 00	 ret	 16			; 00000010H
?AesEncryptMessageV5@@YGHPBEPAEPAKK@Z ENDP		; AesEncryptMessageV5
_TEXT	ENDS
END
